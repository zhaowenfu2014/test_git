/*
//============================================================================================
							4.1.内存这个大话题
//============================================================================================
4.1.1.程序运行为什么需要内存1
4.1.2.程序运行为什么需要内存2
4.1.3.位、字节、半字、字的概念和内存位宽
4.1.4.内存编址和寻址、内存对齐
4.1.5.C语言如何操作内存
4.1.6.内存管理之结构体
4.1.7、内存管理之栈
4.1.8、内存管理之堆
4.1.9、复杂数据结构
//============================================================================================
							4.1.1-2.程序运行为什么需要内存1-2
//--------------------------------------------------------------------------------------------
	1. 计算机程序运行的目的
		
		计算机程序 = 代码 + 数据		
		
		从宏观上来理解, 代码就是动作, 是加工数据的动作; 数据就是数字, 是被代码所加工的东西.
		
		代码 + 数据 (经过运行后) = 结果
		程序运行的目的不外乎2个：结果、过程.

		用函数来类比：函数的形参就是待加工的数据(函数内还需要一些临时数据,就是局部变量), 函
		数本体就是代码, 函数的返回值就是结果, 函数体的执行过程就是过程.
		
		1) // 这个函数的执行就是为了得到结果
			int add(int a, int b)
			{
				return a + b;
			}	
		2) // 这个函数的执行重在过程(重在过程中的printf), 返回值不需要.
			void add(int a, int b)
			{
				int c;
				c = a + b;
				printf("c = %d.\n", c);
			}	
		3) // 这个函数又重结果又重过程
			int add(int a, int b)
			{
				int c;
				c = a + b;
				printf("c = %d.\n", c);
				return c;
			}			
	
	2. 计算机程序运行过程
	
		计算机程序的运行过程, 其实就是程序中很多个函数相继运行的过程. 程序是由很多个函数组
		成的, 程序的本质就是函数, 函数的本质是加工数据的动作.
		
	3. 冯诺依曼结构和哈佛结构
		
		1) 
			冯诺依曼结构是：数据和代码放在一起.
			哈佛结构是：	数据和代码分开存在.
		2) 
			什么是代码：函数.
			什么是数据：全局变量、局部变量.
	
		3) 在S5PV210中运行的linux系统上, 运行应用程序时：这时候所有的应用程序的代码和数据
		   都在DRAM, 所以这种结构就是冯诺依曼结构.
		  
		4) 在单片机中, 我们把程序代码烧写到Flash(NorFlash)中, 然后程序在Flash中原地运行. 
		   程序中所涉及到的数据(全局变量、局部变量)不能放在Flash中, 必须放在RAM(SRAM)中. 这
		   种就叫哈佛结构.
	
	4. 动态内存DRAM和静态内存SRAM
	
		DRAM是动态内存, SRAM是静态内存. 
		
	5. 总结：为什么需要内存呢
	
		1) 内存是用来存储可变数据的, 数据在程序中表现为全局变量、局部变量等.对我们写程序来
		   说非常重要, 对程序运行更是本质相关.
		
		2) 在gcc中, 其实常量也是存储在内存中的.  而大部分单片机中, 常量是存储在flash中的, 也
	 	   就是在代码段.  
		   
		3) 内存对程序来说几乎是本质需求, 越简单的程序需要越少的内存, 而越庞大越复杂的程序需
		   要更多的内存. 为了实现一个功能, 优秀的程序使用更优秀的算法, 占用内存少,运行速度快.
		
		4) 内存管理是我们写程序时很重要的话题. 我们以前学过的了解过的很多编程的关键其实都是
		   为了内存, 譬如说数据结构(数据结构是研究数据如何组织的, 数据是放在内存中的)和算法
		   (算法是为了用更优秀更有效的方法来加工数据, 既然跟数据有关就离不开内存).
	
	6. 深入思考：如何管理内存(无OS时, 有OS时)
	
		1) 对于计算机来说, 内存容量越大则可能性越大, 所以大家都希望自己的电脑内存更大. 我们
		   写程序时如何管理内存就成了很大的问题. 如果管理不善, 可能会造成程序运行消耗过多的
		   内存, 这样迟早内存都被你这个程序吃光了, 当没有内存可用时程序就会崩溃. 所以内存对
		   程序来说是一种资源, 所以管理内存对程序来说是一个重要技术和话题.
		   
		2) 从操作系统角度考虑, 有操作系统时:
		
		   有操作系统角度讲：操作系统掌握所有的硬件内存, 因为内存很大, 所以操作系统把内存分
		   成1个1个的页面(其实就是一块, 一般是4KB), 然后以页面为单位来管理. 页面内用更细小
		   的方式来以字节为单位管理.
		   操作系统内存管理的原理非常麻烦、非常复杂、非常不人性化. 那么对我们这些使用操作系
		   统的人来说, 其实不需要了解这些细节. 操作系统给我们提供了内存管理的一些接口, 我们
		   只需要用API即可管理内存.		
				譬如在C语言中使用malloc free这些接口来管理内存. 
				
		3) 从操作系统角度考虑, 没有有操作系统时:
		
			在没有操作系统(其实就是裸机程序)中, 程序需要直接操作内存, 编程者需要自己计算内存
		   的使用和安排. 如果编程者不小心把内存用错了, 错误结果需要自己承担.
	
		4) 从从语言角度考虑:不同的语言提供了不同的操作内存的接口.
		
			汇编：根本没有任何内存管理, 内存管理全靠程序员自己, 汇编中操作内存时直接使用内存
			      地址(譬如0xd0020010), 非常麻烦.
			C语言：C语言中编译器帮我们管理直接内存地址, 我们都是通过编译器提供的变量名等来访
			      问内存的, 操作系统下如果需要大块内存, 可以通过API(malloc free)来访问系统内
				  存. 裸机程序中需要大块的内存需要自己来定义数组等来解决.
	
			C++语言：C++语言对内存的使用进一步封装. 我们可以用new来创建对象(其实就是为对象分
			      配内存), 然后使用完了用delete来删除对象(其实就是释放内存). 所以C++语言对内
				  存的管理比C要高级一些, 容易一些. 但是C++中内存的管理还是靠程序员自己来做.
				  如果程序员new了一个对象, 但是用完了忘记delete就会造成这个对象占用的内存不
				  能释放, 这就是内存泄漏.
				  
			Java/C#等语言：这些语言不直接操作内存, 而是通过虚拟机来操作内存. 这样虚拟机作为
			     我们程序员的代理, 来帮我们处理内存的释放工作. 如果我的程序申请了内存, 使用
				 完成后忘记释放, 则虚拟机会帮我释放掉这些内存. 听起来似乎C# java等语言比
				 C/C++有优势, 但是其实他这个虚拟机回收内存是需要付出一定代价的, 所以说语言没
				 有好坏, 只有适应不适应. 当我们程序对性能非常在乎的时候(譬如操作系统内核)就
				 会用C/C++语言; 当我们对开发程序的速度非常在乎的时候, 就会用Java/C#等语言.

//============================================================================================
							4.1.3.位、字节、半字、字的概念和内存位宽
//--------------------------------------------------------------------------------------------
	1. 什么是内存? (硬件和逻辑两个角度)
	
		1) 从硬件角度：
		
			内存实际上是电脑的一个配件(一般叫内存条). 根据不同的硬件实现原理还可以把内存分
			成SRAM和DRAM(DRAM又有好多代, 譬如最早的SDRAM, 后来的DDR1、DDR2・・・・・、LPDDR)
			
		2) 从逻辑角度：
		
			内存是这样一种东西: 它可以随机访问(随机访问的意思是只要给一个地址, 就可以访问这
			个内存地址)、并且可以读写(当然了逻辑上也可以限制其为只读或者只写); 内存在编程中
			天然是用来存放变量的(就是因为有了内存, 所以C语言才能定义变量, C语言中的一个变量
			实际就对应内存中的一个单元).
			
		总结: 内存时可以随机访问的, 可读可写, 正好对应变量的存储要求.
			  
	2. 内存的逻辑抽象图(内存的编程模型)
	
		从逻辑角度来讲, 内存实际上是由很多个内存单元格组成的, 每个单元格有一个固定的地址叫
		内存地址, 这个内存地址和这个内存单元格唯一对应且永久绑定. 逻辑上来说, 内存可以有无限
		大(因为数学上编号永远可以增加,无尽头). 但是现实中实际的内存大小是有限制的, 譬如32位
		系统(32位系统指的是32位数据线, 但是一般地址线也是32位, 这个地址线32位决定了内存地址
		只能有32位二进制, 所以逻辑上的大小为2的32次方) 内存限制就为4G. 实际上32位的系统中可
		用的内存是小于等于4G的(譬如我32位CPU装32位windows, 但实际电脑只有512M内存).
		
		总结: 32位系统指的是32位数据线, 地址线可以与数据线相同, 或者不同. 原来的32位windows
              的硬盘也可以大于4G, 是不是说明地址线不是32位???   
			  (?????!!!!!)但是内存只能是4G,及其一下, 是不是还是证明了,地址线就是32位的? 因为
			  硬盘 不是通过内部总线访问的, 所以寻址的范围可以大于4G,并不能说明地址的总线大于
			  32位,因为不是内部总线访问?????
			
	3. 位和字节
	
		1) 内存单元的大小单位有4个：位(1bit),字节(8bit),半字(一般是16bit),字(一般是32bit).
		
		2) 在所有的计算机、所有的机器中(不管是32位系统还是16位系统还是以后的64位系统), 位
		   永远都是1bit, 字节永远都是8bit.
		   
	4. 字和半字
	
		历史上曾经出现过16位系统、32位系统、64位系统三种. 而且操作系统还有windows、linux、
		OS等很多, 所以很多的概念在历史上曾经被混乱的定义过.
		
		建议大家对字、半字、双字这些概念不要详细区分, 只要知道这些单位具体有多少位是依赖
		于平台的. 实际工作中在每种平台上先去搞清楚这个平台的定义(字是多少位, 半字永远是字
		的一半, 双字永远是字的2倍大小).
		
		编程时一般根本用不到字这个概念, 那我们区分这个概念主要是因为有些文档中会用到这些
		概念, 如果不加区别可能会造成你对程序的误解.
		
		在linux+ARM这个软硬件平台上(我们嵌入式核心课的所有课程中), 字是32位的.

	5. 内存位宽(硬件和逻辑两个角度)
	
		1) 从硬件角度讲
			a) 硬件内存的实现本身是有宽度的, 也就是说有些内存条就是8位的, 而有些就是16位的. 
			b) 内存芯片之间是可以并联的, 通过并联后即使8位的内存芯片也可以做出来16位或32位
			   的硬件内存. S5PV210使用的DRAM就是16位的,并联成了32位的内存.
		2) 从逻辑角度讲
			内存位宽在逻辑上是任意的, 甚至逻辑上存在内存位宽是24位的内存(但是实际上这种
			硬件是买不到的, 也没有实际意义). 从逻辑角度来讲不管内存位宽是多少, 我就直接
			操作即可, 对我的操作不构成影响. 但是因为你的操作不是纯逻辑而是需要硬件去执
			行的, 所以不能为所欲为, 所以我们实际的很多操作都是受限于硬件的特性的. 譬如24
			位的内存逻辑上和32位的内存没有任何区别, 但实际硬件都是32位的, 都要按照32位硬
			件的特性和限制来干活.
//============================================================================================
								4.1.4.内存编址和寻址、内存对齐
//--------------------------------------------------------------------------------------------
	1. 内存编址方法
	
		内存在逻辑上就是一个一个的格子, 这些格子可以用来装东西(里面装的东西就是内存中存储
		的数), 每个格子有一个编号, 这个编号就是内存地址. 这个内存地址(一个数字)和这个格子
		的空间(实质是一个空间)是一一对应且永久绑定的, 这就是内存的编址方法.
		
		在程序运行时, 计算机中CPU实际只认识内存地址, 而不关心这个地址所代表的空间在哪里, 
		怎么分布这些实体问题. 因为硬件设计保证了按照这个地址就一定能找到这个格子, 所以说
		内存单元的2个概念：地址和空间是内存单元的两个方面.
		
	2. 关键：内存编址是以字节为单位的
		
			我随便给一个数字(譬如说7), 然后说这个数字是一个内存地址, 然后问你这个内存地址
			对应的空间多大? 这个大小是固定式, 就是一个字节(8bit).

	3. 内存和数据类型的关系
	
		C语言中的基本数据类型有：char short int long float double 
	
		1) int 整形(整数类型, 这个整就体现在它和CPU本身的数据位宽是一样的), 譬如32位的CPU,
		   整形就是32位, int就是32位.
		   
		2) 数据类型和内存的关系就在于：
			数据类型是用来定义变量的, 而这些变量需要存储、运算在内存中. 所以数据类型必须和
			内存相匹配才能获得最好的性能, 否则可能不工作或者效率低下.
			
			在32位系统中定义变量最好用int, 因为这样效率高. 原因就在于32位的系统本身配合内存
			等也是32位, 这样的硬件配置天生适合定义32位的int类型变量, 效率最高. 也能定义8位
			的char类型变量或者16位的short类型变量, 但是实际上访问效率不高.
			
			在很多32位环境下, 我们实际定义bool类型变量(实际只需要1个bit就够了)都是用int来实
			现bool的. 也就是说我们定义一个bool b1;时, 编译器实际帮我们分配了32位的内存来存
			储这个bool变量b1. 编译器这么做实际上浪费了31位的内存, 但是好处是效率高.
			
		问题：实际编程时要以省内存为大还是要以运行效率为重? 答案是不定的, 看具体情况. 很多
		      年前内存很贵机器上内存都很少, 那时候写代码以省内存为主. 现在随着半导体技术的
			  发展内存变得很便宜了, 现在的机器都是高配, 不在乎省一点内存, 而效率和用户体验
			  变成了关键. 所以现在写程序大部分都是以效率为重.
			  
		总结: 结构体里面的内存对齐,C语言里面的位段等等都是为了适应这个问题.
				
	
	4. 内存对齐
		我们在C中 int a;定义一个int类型变量, 在内存中就必须分配4个字节来存储这个a, 有这么2种
		不同内存分配思路和策略：
			第一种：0 1 2 3									对齐访问
			第二种：1 2 3 4	或者 2 3 4 5 或者 3 4 5 6 		非对齐访问
		内存的对齐访问不是逻辑的问题, 是硬件的问题. 从硬件角度来说, 32位的内存它 0 1 2 3四个
		单元本身逻辑上就有相关性, 这4个字节组合起来当作一个int硬件上就是合适的, 效率就高.
		对齐访问很配合硬件, 所以效率很高; 非对齐访问因为和硬件本身不搭配, 所以效率不高. (因
		为兼容性的问题, 一般硬件也都提供非对齐访问, 但是效率要低很多.)
	
	5. 从内存编址看数组的意义
		1) 数组就是在内存中截取的一段.
		2) 数组名就是首元素的首地址. 比如int型数组, 每个元素对应四个地址, 首地址就首元素对应的
	       哪个最小的地址编号.

//============================================================================================
								4.1.5.C语言如何操作内存
//--------------------------------------------------------------------------------------------
4.1.5.C语言如何操作内存


	1. C语言对内存地址的封装(用变量名来访问内存、数据类型的含义、函数名的含义)
	
		譬如在C语言中 int a; a = 5; a += 4;		// a == 9;

		结合内存来解析C语言语句的本质：
			int a;	// 编译器帮我们申请了1个int类型的内存格子(长度是4字节, 地址是确定的,
					// 但是只有编译器知道, 我们是不知道的, 也不需要知道), 并且把符号a和
					// 这个格子绑定.
			a = 5;	// 编译器发现我们要给a赋值, 就会把这个值5丢到符号a绑定的那个内存格子中.
			a += 4;	// 编译器发现我们要给a加值, a += 4 等效于 a = a + 4; 编译器会先把a原来
			        // 的值读出来, 然后给这个值加4, 再把加之后的和写入a里面去.
	
	2. C语言中数据类型的本质含义是：表示一个内存格子的长度和解析方法(!!!!!*****!!!!!). 
	
		1) 数据类型决定长度的含义：我们一个内存地址(0x30000000), 本来这个地址只代表1个字节
		   的长度, 但是实际上我们可以通过给他一个类型(int), 让他有了长度(4), 这样这个代表内
		   存地址的数字(0x30000000)就能表示从这个数字(0x30000000)开头的连续的n(4)个字节的内
		   存格子了(0x30000000 + 0x30000001 + 0x30000002 + 0x30000003).
		
		2) 数据类型决定解析方法的含义：譬如我有一个内存地址(0x30000000), 我们可以通过给这个
		   内存地址不同的类型来指定这个内存单元格子中二进制数的解析方法. 
		   譬如 (int)0x30000000, 含义就是(0x30000000 + 0x30000001 + 0x30000002 + 0x30000003)
		   这4个字节连起来共同存储的是一个int型数据; 那么我(float)0x30000000, 含义就是
		   (0x30000000 + 0x30000001 + 0x30000002 + 0x30000003)这4个字节连起来共同存储的是一
		   个float型数据.
		   同样的内存存储内容, 类型不同, 解析出来的数值也不同. 
	
		总结: 之前讲过一个很重要的概念：内存单元格子的编址单位是字节。
			(int *)0x30000000;
			(float *)0x30000000;
			
			0x30000000是一个指针, 就是地址. 如果是(int *)则该地址就是一个int类型的变量的地址
			(首地址), 如果是(float *)型,则该地址就是一个float类型的变量的地址(首地址).
	
			int a;			// int a;时编译器会自动给a分配一个内存地址，譬如说是0x12345678
			(int *)a;		// 等价于(int *)0x12345678, a是一个指向int类型变量的指针.
			(float *)a;		// a是一个指向float类型变量的指针.
	
	3. 函数名: 代码的地址.
	
		1) C语言中, 函数就是一段代码的封装. 
		2) 函数名的实质就是这一段第一条代码的首地址. 所以说函数名的本质也是一个内存地址.

	4. 用指针来间接访问内存
	
		关于类型(不管是普通变量类型int float等, 还是指针类型int *   float *等), 只要记住：
		
		类型只是对后面数字或者符号(代表的是内存地址)所表征的内存的一种长度规定和解析方法
		规定而已.
		
		C语言中的指针, 全名叫指针变量, 指针变量其实跟普通变量没有任何区别. 譬如int a和int *p
		其实没有任何区别, a和p都代表一个内存地址(譬如是0x20000000), 但是这个内存地址
		(0x20000000)的长度和解析方法不同. a是int型所以a的长度是4字节, 解析方法是按照int的规
		定来的; p是int *类型, 所以长度是4字节, 解析方法是int *的规定来的(0x20000000开头的连
		续4字节中存储了1个地址, 这个地址所代表的内存单元中存放的是一个int类型的数). 
		
	5. 用数组来管理内存
		1) 数组管理内存和变量其实没有本质区别, 只是符号的解析方法不同.
		   (普通变量、数组、指针变量其实都没有本质差别, 都是对内存地址的解析, 只是解析方法不
		   一样).
		   
			int a;		// 编译器分配4字节长度给a, 并且把首地址和符号a绑定起来.
			int b[10];	// 编译器分配40个字节长度给b, 并且把首元素首地址和符号b绑定起来.

		2) 数组中第一个元素(a[0]) 就称为首元素; ；每一个元素类型都是int, 所以长度都是4, 其中
		   第一个字节的地址就称为首地址; 首元素a[0]的首地址就称为首元素首地址.
//============================================================================================
								4.1.6.内存管理之结构体
//--------------------------------------------------------------------------------------------
4.1.6.内存管理之结构体


	1. 数据结构这门学问的意义
		
		数据结构就是研究数据如何组织(在内存中排布), 如何加工的学问.
		
		(数据结构包含:数组, 栈, 堆, 链表, 二叉树, 哈希表, 图...等)
		
	2. 最简单的数据结构：数组
	
		1) 为什么要有数组? 因为程序中有好多个类型相同、意义相关的变量需要管理, 这时候如果
		   用单独的变量来做程序看起来比较乱, 用数组来管理会更好管理.
			譬如 int ages[20];
		
		2) 数组的优势和缺陷
			优势：数组比较简单, 访问用下标, 可以随机访问.
			缺陷：
				  a) 数组中所有元素类型必须相同.
				  b) 数组大小必须定义时给出, 而且一旦确定不能再改. 这种结构,不具有伸缩性.
				  
	3. 结构体隆重登场
	
		结构体发明出来就是为了解决数组的第一个缺陷：数组中所有元素类型必须相同
	
		struct people
		{
			int age;			// 人的年龄
			char name[20];		// 人的姓名
			int height;			// 人的身高
		};
	
	4. 题外话：结构体内嵌指针实现面向对象

		1) 面向过程与面向对象

			总的来说：C语言是面向过程的, 但是C语言写出的linux系统是面向对象的.
		
		2)	非面向对象的语言, 不一定不能实现面向对象的代码. 只是说用面向对象的语言来实现面
			向对象要更加简单一些、直观一些、无脑一些.
			
			用C++、Java等面向对象的语言来实现面向对象简单一些, 因为语言本身帮我们做了很多
			事情; 但是用C来实现面向对象很麻烦, 看起来也不容易理解, 这就是为什么大多数人学过
			C语言却看不懂linux内核代码的原因.
		3) 
			struct s
			{
				int age;					// 普通变量
				void (*pFunc)(void);		// 函数指针，指向 void func(void)这类的函数
			};

			使用这样的结构体就可以实现面向对象.
			
			这样包含了函数指针的结构体就类似于面向对象中的class, 结构体中的变量类似于class
			中的成员变量, 结构体中的函数指针类似于class中的成员方法.

//============================================================================================
								4.1.7、内存管理之栈
//--------------------------------------------------------------------------------------------
	1. 什么是栈
		
		1) 栈是一种数据结构, C语言中使用栈来保存局部变量. 栈是被发明出来管理内存的.
		
		2) 一般说的堆栈, 指的就是栈.
		
		3) 栈, 自动化分配的小内存.
		
	2. 栈管理内存的特点(小内存、自动化)
	
		先进后出 FILO	first in last out		栈
		
		先进先出 FIFO   first in first out  	队列
		
		1) 栈的特点是入口即出口, 只有一个口, 另一个口是堵死的. 所以先进去的必须后出来.

		2) 队列的特点是入口和出口都有, 必须从入口进去, 从出口出来, 所以先进去的必须先
		   出来, 否则就堵住后面的.
		
	3. 栈的应用举例：局部变量
	
		C语言中的局部变量是用栈来实现的.
		
		我们在C中定义一个局部变量时(int a), 编译器会在栈中分配一段空间(4字节)给这个局部
		变量用(分配时栈顶指针会移动给出空间, 给局部变量a用的意思就是, 将这4字节的栈内存
		的内存地址和我们定义的局部变量名a给关联起来), 对应栈的操作是入栈.
		
		
		注意：这里栈指针的移动和内存分配是自动的(栈自己完成, 不用我们写代码去操作),	然后
		      等我们函数退出的时候, 局部变量要灭亡. 对应栈的操作是弹栈(出栈). 出栈时也是
			  栈顶指针移动将栈空间中与a关联的那4个字节空间释放. 这个动作也是自动的, 也不
			  用人写代码干预.
	
	4. 栈的优点：
		
		栈管理内存, 好处是方便, 分配和最后回收都不用程序员操心, C语言自动完成.
		
	5. 局部变量的初始化
	
		1) C语言中, 定义局部变量时如果未初始化, 则值是随机的. 
		
			定义局部变量, 其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变
		    量名绑定. 因为这段内存空间在栈上, ，而栈内存是反复使用的(脏的, 上次用完没清零
			的), 所以说使用栈来实现的局部变量定义时如果不显式初始化, 值就是脏的. 
		 
		 2) 显式初始化局部变量

			C语言是通过一个小手段来实现局部变量的初始化的.
			
				int a = 15;		// 局部变量定义时初始化

				C语言编译器会自动把这行转成：

				int a;			// 局部变量定义
				a = 15;			// 普通的赋值语句

	6. 栈的约束(预定栈大小不灵活, 怕溢出)
	
		1) 栈是有大小的. 所以栈内存大小不好设置. 如果太小怕溢出, 太大怕浪费内存. (这个缺点有
		   点像数组)
		   
		2) 栈的溢出危害很大, 一定要避免. 所以我们在C语言中定义局部变量时不能定义太多或者太大
		   (譬如不能定义局部变量时 int a[10000]; 使用递归来解决问题时一定要注意递归收敛, 
		    因为递归函数使用的局部变量都压在了栈中).
		   
		   (!!!!!)C语言中并没有检查栈溢出的机制.

//============================================================================================
								4.1.8、内存管理之堆
//--------------------------------------------------------------------------------------------
	1. 什么是堆
	
		1) 堆(heap)是一种内存管理方式. 内存管理对操作系统来说是一件非常复杂的事情: 首先内存
		   容量很大, 其次内存需求在时间和大小块上没有规律(操作系统上运行着的几十、几百、几千
		   个进程随时都会申请或者释放内存, 申请或者释放的内存块大小随意).
		   
		   (因此操作系统使用了很多的内存管理方法,包括栈,堆...等等)

		2) 堆这种内存管理方式特点就是自由(随时申请、释放; 大小块随意). 
		
		3) 堆内存是操作系统划归给堆管理器(操作系统中的一段代码, 属于操作系统的内存管理单元)
		   来管理的, 然后向使用者(用户进程)提供API(malloc和free)来使用堆内存.
		   
	2. 我们什么时候使用堆内存?
		
		需要内存容量比较大时, 需要反复使用及释放时, 很多数据结构(譬如链表)的实现都要使用堆
		内存.
		
	3. 堆管理内存的特点(大块内存、手工分配&使用&释放)
	
		特点一：容量不限(常规使用的需求容量都能满足).
		特点二：申请及释放都需要手工进行, 手工进行的含义就是需要程序员写代码明确进行申请
		         malloc及释放free. 如果程序员申请内存并使用后未释放, 这段内存就丢失了(在堆
				 管理器的记录中, 这段内存仍然属于你这个进程, 但是进程自己又以为这段内存已
				 经不用了, 再用的时候又会去申请新的内存块, 这就叫吃内存), 称为内存泄漏.
				 
				 在C/C++语言中, 内存泄漏是最严重的程序bug, 这也是别人认为Java/C#等语言比
				 C/C++ 优秀的地方.
				 
	4. C语言操作堆内存的接口（malloc free）

		1) 堆内存释放时最简单, 直接调用free释放即可. 	void free(void *ptr);
		
		2) 堆内存申请时, 有3个可选择的类似功能的函数：malloc, calloc, realloc

			void *malloc(size_t size);					// 单位 字节.
			void *calloc(size_t nmemb, size_t size);	// nmemb个单元，每个单元size字节
			void *realloc(void *ptr, size_t size);		// 改变原来申请的空间的大小的

			譬如要申请10个int元素的内存：
			malloc(40);			malloc(10*sizeof(int));		// 后者可移植性更好.
			calloc(10, 4);		calloc(10, sizeof(int));

		3) 数组定义时必须同时给出数组元素个数(数组大小), 而且一旦定义再无法更改. 在Java
		   等高级语言中, 有一些语法技巧可以更改数组大小, 但其实这只是一种障眼法. 它的工作
		   原理是：先重新创建一个新的数组大小为要更改后的数组, 然后将原数组的所有元素复制
		   进新的数组, 然后释放掉原数组, 最后返回新的数组给用户.

		4) 堆内存申请时必须给定大小, 然后一旦申请完成大小不变, 如果要变只能通过realloc接口.
		   realloc的实现原理类似于上面说的Java中的可变大小的数组的方式.
		   
		   现申请一个大的, 然后把原来小的内存内容复制过去, 把原来的内存空间释放, 返回新的
		   地址指针.
		   
	5. 堆的优势和劣势(管理大块内存、灵活、容易内存泄漏)
	
		优势：灵活；
		劣势：需要程序员去处理各种细节, 所以容易出错, 严重依赖于程序员的水平.

//============================================================================================
								4.1.9、复杂数据结构
//--------------------------------------------------------------------------------------------
	1. 链表、哈希表、二叉树、图等
	
		1) 链表是最重要的, 链表在linux内核中使用非常多, 驱动、应用编写很多时候都需要使用链表.
		   所以对链表必须掌握, 掌握到: 会自己定义结构体来实现链表、会写链表的节点插入(前插、
		   后插)、节点删除、节点查找、节点遍历等. (至于像逆序这些很少用, 掌握了前面那几个这
		   个也不难).

		2) 哈希表不是很常用, 一般不需要自己写实现, 而直接使用别人实现的哈希表比较多. 对我们来
		   说最重要的是要明白哈希表的原理、从而知道哈希表的特点, 从而知道什么时候该用哈希表,
		   当看到别人用了哈希表的时候要明白别人为什么要用哈希表、合适不合适? 有没有更好的选择?
	
			哈希表类似数组.	哈希表 key 与 序号存在一个计算公式. 与数组对比, 数组的key等于序
			号, 直接用序号访问元素.
			
		3) 二叉树、图等. 对于这些复杂数据结构, 不要太当回事. 这些复杂数据结构用到的概率很小
		   (在嵌入式开发中), 其实这些数据结构被发明出来就是为了解决特定问题的, 你不处理特定
		   问题根本用不到这些, 没必要去研究.

			做数据库, 搜索算法等等可能用到二叉树....

	2. 为什么需要更复杂的数据结构

		因为现实中的实际问题是多种多样的, 问题的复杂度不同, 所以需要解决问题的算法和数据结
		构也不同. 所以当你处理什么复杂度的问题, 就去研究针对性解决的数据结构和算法; 当你没
		有遇到此类问题(或者你工作的领域根本跟这个就没关系)时就不要去管了.

	3. 数据结构和算法的关系

		数据结构的发明都是为了配合一定的算法; 算法是为了处理具体问题, 算法的实现依赖于相应
		的数据结构.
		
		当前我们说的算法和纯数学是不同的, 计算机算法要求以数学算法为指导, 并且结合计算机本
		身的特点来改进, 最终实现一个在计算机上可以运行的算法(意思就是用代码可以表示的算法).

	4. 应该怎样学习这部分？
		
		从上面表述大家应该明白以下事实：
		
		1) 数据结构和算法是相辅相成的，要一起研究。
		2) 数据结构和算法对嵌入式来说不全是重点, 不要盲目的跑去研究这个.
		3) 一般在实际应用中, 实现数据结构和算法的人和使用数据结构和算法的人是分开的. 实际中
		   有一部分人的工作就是研究数据结构和算法, 并且试图用代码来实现这些算法(表现为库);
		   其他做真正工作的人要做的就是理解、明白这些算法和数据结构的意义、优劣、特征, 然后
		   在合适的时候选择合适的数据结构和算法来解决自己碰到的实际问题.

		举个例子：linux内核在字符设备驱动管理时, 使用了哈希表(hash table,散列表). 所以字符设
		          备驱动的很多特点都和哈希表的特点有关.
				  
		总结: 哈希表, 散列表, 其实就是映射表.

//============================================================================================




