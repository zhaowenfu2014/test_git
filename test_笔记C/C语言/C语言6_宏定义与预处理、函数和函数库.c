/*
//=======================================================================================================
							4.6.C语言宏定义与预处理、函数和函数库
//=======================================================================================================
4.6.1.C语言预处理理论
4.6.2.C语言预处理代码实战
4.6.3.宏定义1
4.6.4.宏定义2
4.6.5.函数的本质
4.6.6.函数的基本使用
4.6.7.递归函数
4.6.8.函数库
4.6.9.字符串函数
4.6.10.数学库函数
4.6.11.自己制作静态链接库并使用
4.6.12.自己制作动态链接库并使用
//=======================================================================================================
									4.6.1.C语言预处理理论
//-------------------------------------------------------------------------------------------------------
	1. 由源码到可执行程序的过程
		1) 源码.c->(编译)->elf可执行程序
		2) 源码.c->(编译)->目标文件.o->(链接)->elf可执行程序
		3) 源码.c->(编译)->汇编文件.S->(汇编)->目标文件.o->(链接)->elf可执行程序
		4) 源码.c->(预处理)->预处理过的.i源文件->(编译)->汇编文件.S->(汇编)->目标文件.o->(链接)
																							->elf可执行程序
		(这里完整的过程就是4, 前面都是简单的过程, 比如 gcc main.c就是1情况).
		
		预处理用预处理器, 编译用编译器, 汇编用汇编器, 链接用链接器, 这几个工具再加上其他一些额外的会用
		到的可用工具, 合起来叫编译工具链. gcc就是一个编译工具链.
	
	2. 进一步说明
		1) gcc main.c 
			a) 编译连接生成可执行文件
			b) 名称为a.out
		2) gcc main.c -o main
			a) -o指定可执行文件名称.
		3) gcc -c hello.c 
			a) -c 就是只编译不连接. 
			b) -c位置可以放在左边或者右边.
			c) 不用-o指定名称, 默认名称就是hello.o
		4) 之前裸机的makefile
			led.bin: start.o 
				arm-linux-ld -Ttext 0x0 -o led.elf $^				# 生成.elf可执行程序
				arm-linux-objcopy -O binary led.elf led.bin			# 生成可烧写的.bin文件(镜像)
				arm-linux-objdump -D led.elf > led_elf.dis			# 生成反汇编文件
				gcc mkv210_image.c -o mkx210						# ubuntu下编译得到mkx210k程序.
				./mkx210 led.bin 210.bin							# 运行mkx210k,从led.bin生成210.bin
				
			%.o : %.S
				arm-linux-gcc -o $@ $< -c			# -c 只编译不连接,否则编译器会编译为可执行程序.

			%.o : %.c
				arm-linux-gcc -o $@ $< -c 
			
	3. 预处理的意义
	
		1) 编译器本身的主要目的是编译源代码, 将C的源代码转化成.S的汇编代码. 编译器聚焦核心功能后, 就
		   剥离出了一些非核心的功能到预处理器去了.
		2) 预处理器帮编译器做一些编译前的杂事. 

	4. 编程中常见的预处理
		
		1) #include（#include <>和#include ""的区别）
		2) 注释
		3) #if #elif #endif		#ifdef
		4) 宏定义
		5) 预处理命令#pragma  (本文档不涉及这个用法)
	
		(在所有的预处理指令中, #pragma 指令可能是最复杂的了,它的作用是设定编译器的状态或者是指示编译器
		 完成一些特定的动作. #pragma指令对每个编译器给出了一个方法, 在保持与C和C++语言完全兼容的情况下,
		 给出主机或操作系统专有的特征.)
		 
	5. gcc中只预处理不编译的方法 : gcc -E xx.c -o xx.i
	
		1) gcc编译时可以给一些参数来做一些设置, 比如:
			a) gcc xx.c -o xx可以指定可执行程序的名称.
			b) gcc xx.c -c -o xx.o可以指定只编译不连接, 也可以生成.o的目标文件.
			
		2) gcc -E xx.c -o xx.i 可以实现只预处理不编译. 
		   
		   一般情况下没必要只预处理不编译, 但有时候这种技巧可以用来帮助我们研究预处理过程, 帮助debug程序.
		   
		   (如果不写-o xx.i, 则ubuntu的终端会显示.i的内容, 但不生成文件)

		总结：宏定义被预处理时的现象有：第一, 宏定义语句本身不见了(可见编译器根本就不认识#define, 编译器
		      根本不知道还有个宏定义), 第二, typedef重命名语言还在, 说明它和宏定义是有本质区别的(说明
			  typedef是由编译器来处理而不是预处理器处理的).
			  
	6. 预处理器处理的.i文件.
		1) .c 文件
			#define pchar char *
			typedef char * PCHAR;						// ; 号不能丢!!!!!

			int main(void)
			{
				pchar p3;
				pchar p1, p2;
				
				return 0;
			}
		2) gcc -E xx.c -o xx.i
			# 1 "4.6.1.preprocess.c"
			# 1 "<command-line>"
			# 1 "/usr/include/stdc-predef.h" 1 3 4
			# 1 "<command-line>" 2
			# 1 "4.6.1.preprocess.c"

			typedef char * PCHAR;

			int main(void)
			{
				char * p3;
				char * p1, p2; 

				return 0;
			}

//=======================================================================================================
									4.6.2.C语言预处理代码实战
//-------------------------------------------------------------------------------------------------------
	1. 头文件包含

		1) 真是含义: #inclede的那一行, 预处理器会把.h内容复制过去.
		
		2) #include <> ：<>专门用来包含系统提供的头文件(就是系统自带的, 不是程序员自己写的).
						 C语言编译器只会到系统指定目录(编译器中配置的或者操作系统配置的寻找目录, 譬如
						 在ubuntu中是/usr/include目录, 编译器还允许用-I来附加指定其他的包含路径)去寻
						 找这个头文件(隐含意思就是不会找当前目录下), 如果找不到就会提示这个头文件不存在.

		3) #include "" : "" 用来包含自己写的头文件; 编译器默认会先在当前目录下寻找相应的头文件, 如果没
		                 找到然后再到系统指定目录去寻找, 如果还没找到则提示文件不存在.
						 
		总结：
				1) 规则虽然允许用双引号来包含系统指定目录, 但是一般的使用原则是: 如果是系统指定的自带的
				   用<>, 如果是自己写的在当前目录下放着用"", 如果是自己写的但是集中放在了一起专门存放头
				   文件的目录下, 用<>. 将来在编译器中用-I参数来寻找.
				   
				2) 编译器用-I来附加指定其他的包含路径.

	2. 注释
	
		1) 注释是给人看的, 不是给编译器看的.
		
		2) 编译器既然不看注释, 那么编译时最好没有注释的. 实际上在预处理阶段, 预处理器会拿掉程序中所有的
		   注释语句, 到了编译器编译阶段程序中其实已经没有注释了. 可以查看.i文件.

	3. 条件编译
	
		1) 有时候我们希望程序有多种配置, 我们在源代码编写时写好了各种配置的代码, 然后给个配置开关, 在源
		   代码级别去修改配置开关来让程序编译出不同的效果.
	   
		2) 条件编译中用的两种条件判定方法分别是#ifdef 和 #if

			区别：#ifdef XXX判定条件成立与否时主要是看XXX这个符号在本语句之前有没有被定义, 只要定义了
			      (我们可以直接#define XXX或者#define XXX 12或者#define XXX YYY) 这个符号就是成立的.
			格式: #if (条件表达式), 它的判定标准是()中的表达式是否为true还是flase.
			
	4. 条件编译举例:
		
		1) 	#ifdef  		#elif    	#endif
		2) 	#ifndef			#elif		#endif
		3)  #if(xxx==yyy)	#elif		#endif

//=======================================================================================================
										4.6.3.宏定义1
//-------------------------------------------------------------------------------------------------------
	1. 宏定义的规则和使用解析
	
		1) 宏定义的解析规则就是：在预处理阶段由预处理器进行替换, 这个替换是原封不动的替换.
		
		2) 宏定义替换会递归进行, 直到替换出来的值本身不再是一个宏为止.
		
		3) 一个正确的宏定义式子本身分为3部分：第一部分是#dedine, 第二部分是宏名, 剩下的所有为第三部分.
			a) #define 空格后的内容为宏名.
			b) 宏名不能有空格.
			c) 宏名后面的空格的后面, 就是定义的内容. 如果内容可以还有空格.
			
		4) 宏可以带参数, 称为带参宏.
			带参宏的使用和带参函数非常像, 但是使用上有一些差异. 在定义带参宏时, 每一个参数在宏体中引用
			时都必须加括号, 最后整体再加括号, 括号缺一不可.

	2. 宏定义示例
	
		1) MAX宏，求2个数中较大的一个
			
			#define MAX(a, b) (((a)>(b)) ? (a) : (b))
			
			关键：
				第一点：要想到使用三目运算符来完成.
				第二点：注意括号的使用. 尤其是"(((a)>(b)) ?" 的括号不能少些.
				        max = MAX(2+x, y); 这里调用时,如果没有括号, 会警告.

		2) 用宏定义表示一年中有多少秒

			#define SEC_PER_YEAR	(365*24*60*60UL)

			关键：
				第一点: 当一个数字直接出现在程序中时, 它的是类型默认是int.
				第二点：一年有多少秒, 这个数字刚好超过了int类型存储的范围.

	总结: 
			1) 当一个数字直接出现在程序中时, 默认的类型时int型. 超过int时, 可以定义为long型的常数(L).
			2) (365*24*60*60)UL 编译报错.

//=======================================================================================================
										4.6.4.宏定义2
//-------------------------------------------------------------------------------------------------------
	1. 带参宏和带参函数的区别(宏定义的缺陷)
	
		1) 宏定义是在预处理期间处理的, 而函数是在编译期间处理的. 这个区别带来的实质差异是：宏定义最终
		   是在调用宏的地方把宏体原地展开, 而函数是在调用函数处跳转到函数中去执行, 执行完后再跳转回来.
		   
		   宏定义是原地展开, 因此没有调用开销; 而函数是跳转执行再返回, 因此函数有比较大的调用开销. 所以
		   宏定义和函数相比, 优势就是没有调用开销, 没有传参开销, 所以当函数体很短(尤其是只有一句话时)可
		   以用宏定义来替代, 这样效率高.
		   
		2) 带参宏和带参函数的一个重要差别就是：宏定义不会检查参数的类型, 返回值也不会附带类型; 而函数有
		   明确的参数类型和返回值类型. 当我们调用函数时编译器会帮我们做参数的静态类型检查, 如果编译器
		   发现我们实际传参和参数声明不同时会报警告或错误.
		   
		注：用函数的时候程序员不太用操心类型不匹配因为编译器会检查, 如果不匹配编译器会报错误或警告; 用
		    宏的时候程序员必须很注意实际传参和宏所希望的参数类型一致, 否则可能编译不报错但是运行有误.
			
		总结：宏和函数各有千秋, 各有优劣. 总的来说, 如果代码比较多用函数适合而且不影响效率; 但是对于那
		      些只有一两句话的函数开销就太大了, 适合用带参宏. 但是用带参宏又有缺点：不检查参数类型.
			  
	2. 宏不检查类型举例
		#define MAX(a, b) (((a)>(b)) ? (a) : (b))     // 可能本义是用来比较两个整数.
		
		float a, b, c;
		a = 1.3;
		b = 4.5;
		c = max(a, b);	
		
		(宏的定义者可能是用来比较两个整数, 但是使用者可能会比较float类型的数据. 类似用法可能会出问题)
	

	3. 内联函数和inline关键字
	
		1) 内联函数通过在函数定义前加inline关键字实现.
		2) 内联函数本质上是函数, 所以有函数的优点(内联函数是编译器负责处理的, 编译器可以帮我们做参数的
		   静态类型检查); 但是他同时也有带参宏的优点(不用调用开销, 而是原地展开). 
		   所以几乎可以这样认为：内联函数就是带了参数静态类型检查的宏.
		3) 当我们的函数内函数体很短(譬如只有一两句话)的时候, 我们又希望利用编译器的参数类型检查来排错,
		   我还希望没有调用开销时, 最适合使用内联函数.
		   
		内联函数举例(STM32工程) , 函数体内也可以有定义的数据变量.
		
		__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
		{
		  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      //
			  ((ITM->TER & 1UL               ) != 0UL)   )     //
		  {
			while (ITM->PORT[0U].u32 == 0UL)
			{
			  __NOP();
			}
			ITM->PORT[0U].u8 = (uint8_t)ch;
		  }
		  return (ch);
		}
		

	4. 宏定义来实现条件编译(#define #undef #ifdef)
	
		1) 程序有DEBUG版本和RELEASE版本, 区别就是编译时有无定义DEBUG宏.
		2) #undef 取消定义的宏. 或者重定义宏为另一个值.

		//#define DEBUG
		#undef DEBUG		// 注销一个宏。如果前面有定义这个宏则取消这个宏

		#ifdef DEBUG
		#define debug(x)	printf(x)
		#else
		#define debug(x)	
		#endif

//=======================================================================================================
										4.6.5.函数的本质
//-------------------------------------------------------------------------------------------------------
	1. C语言为什么会有函数
	
		1) 整个程序分成多个源文件, 一个文件分成多个函数, 一个函数分成多个语句, 这就是整个程序的组织形式.
		   这样组织的好处在于：分化问题、便于编写程序、便于分工.
		2) 函数的出现是人(程序员和架构师)的需要, 而不是机器(编译器、CPU)的需要.
		3) 函数的目的就是实现模块化编程, 说白了就是为了提供程序的可移植性.

	2. 函数书写的一般原则：
	
		第一：遵循一定格式. 函数的返回类型、函数名、参数列表等.
		第二：一个函数只做一件事：函数不能太长也不宜太短, 原则是一个函数只做一件事情.
		第三：传参不宜过多：在ARM体系下, 传参不宜超过4个. 如果传参确实需要多则考虑结构体打包.		
		第四：尽量少碰全局变量：函数最好用传参返回值来和外部交换数据, 不要用全局变量.
		
		总结:	
				1) 函数最好用传参返回值来和外部交换数据, 不要用全局变量.
				2) 如果函数使用了全局变量, 就破坏了函数的模块化设计. 
				3) 没有使用全局变量的函数可以用在任何程序,文件使用. 使用了全局变量的函数,在移植到别的
				   环境下(文件,程序下)时, 需要修改.	

	3. 函数是动词、变量是名词(面相对象中分别叫方法和成员变量)
	
		1) 函数将来被编译成可执行代码段, 变量(主要指全局变量)经过编译后变成数据或者在运行时变成数据.
		   一个程序的运行需要代码和数据两方向的结合才能完成.
		2) 代码和数据需要彼此配合, 代码是为了加工数据, 数据必须借助代码来起作用.
		   拿现实中的工厂来比喻：数据是原材料, 代码是加工流水线. 名词性的数据必须经过动词性的加工才能
		   变成最终我们需要的产出的数据. 这个加工的过程就是程序的执行过程.

	4. 函数的实质是：数据处理器

		1) 程序的主体是数据, 也就是说程序运行的主要目标是生成目标数据, 我们写代码也是为了目标数据.我们
		   如何得到目标数据? 必须2个因素：原材料+加工算法. 原材料就是程序的输入数据, 加工算法就是程序.
		2) 程序的编写和运行就是为了把原数据加工成目标数据, 所以程序的实质就是一个数据处理器.
		3) 函数就是程序的一个缩影, 函数的参数列表其实就是为了给函数输入原材料数据, 函数的返回值和输出型
		   参数就是为了向外部输出目标数据, 函数的函数体里的那些代码就是加工算法.
		4) 函数在静止没有执行的时候就好象一台没有开动的机器, 此时只占一些存储空间但是并不占用资源
		   (CPU+内存); 函数的每一次运行就好象机器的每一次开机运行, 运行时需要耗费资源(CPU+内存), 运行时
		   可以对数据加工生成目标数据; 函数运行完毕会释放占用的资源.
		5) 整个程序的运行其实就是很多个函数相继运行的连续过程.

//=======================================================================================================
									4.6.6.函数的基本使用
//-------------------------------------------------------------------------------------------------------
	1. 函数三要素：定义、声明、调用

		1) 函数的定义就是函数体、函数声明是函数原型、函数调用就是使用函数.
		2) 函数定义是函数的根本, 函数定义中的函数名表示了这个函数在内存中的首地址, 所以可以用函数名来
		   调用执行这个函数(实质是指针解引用访问); 函数定义中的函数体是函数的执行关键, 函数将来执行时
		   主要就是执行函数体. 
		3) 函数声明的主要作用是告诉编译器函数的原型.
		4) 函数调用就是调用执行一个函数。

	2. 函数原型和作用
	
		1) 函数原型就是函数的声明, 说白了就是函数的函数名、返回值类型、参数列表.
		2) 函数原型的主要作用就是给编译器提供原型, 让编译器在编译程序时帮我们进行参数的静态类型检查.
		3) 必须明白：编译器在编译程序时是以单个源文件为单位的(所以一定要在哪里调用在哪里声明), 而且编译
		   器工作时已经经过预处理处理了, 最最重要的是编译器编译文件时是按照文件中语句的先后顺序执行的.
		4) 编译器从源文件的第一行开始编译, 遇到函数声明时就会收到编译器的函数声明表中, 然后继续向后.
		   当遇到一个函数调用时, 就在我的本文件的函数声明表中去查这个函数, 看有没有原型相对应的一个函数
		   (这个相对应的函数有且只能有一个). 如果没有或者只有部分匹配则会报错或报警告; 如果发现多个则会
		   报错或报警告(函数重复了, C语言中不允许2个函数原型完全一样, 这个过程其实是在编译器遇到函数定义
		   时完成的. 所以函数可以重复声明但是不能重复定义).

		总结:
				1) 函数原型是给编译器使用的, 让编译器在编译程序时帮我们进行参数的静态类型检查.
				2) (?????)函数的输入参数类型和个数, 据定了编译器采用什么策略传递这些参数(用Rn, 还是
				   堆栈...)???
				3) 编译器是以.c文件为单位编译, 调用函数的地方,一定要先声明.
				4) 函数可以重复声明, 但是不能重复定义.
				
	3. 函数传参
		1) 函数参数个数和类型要匹配.
		2) 个数太多的话, 用一个结构体打包, 用结构体指针作为参数传递.
		3) 如果是输入型参数, 加const修饰.

//=======================================================================================================
										4.6.7.递归函数
//-------------------------------------------------------------------------------------------------------
	1. 什么是递归函数
		1) 递归函数就是函数中调用了自己本身这个函数的函数.
		2) 递归函数和循环的区别. 递归不等于循环.
		3) 递归函数解决问题的典型就是：求阶乘、求斐波那契数列.

	2. 函数的递归调用原理
		1) 实际上递归函数是在栈内存上递归执行的, 每次递归执行一次就需要耗费一些栈内存.
		2) 栈内存的大小是限制递归深度的重要因素.

	3. 使用递归函数的原则：收敛性、栈溢出
		1) 收敛性就是说：递归函数必须有一个终止递归的条件. 当每次这个函数被执行时, 我们判断一个条件
		   决定是否继续递归, 这个条件最终必须能够被满足. 如果没有递归终止条件或者这个条件永远不能被
		   满足, 则这个递归没有收敛性, 这个递归最终要失败.
		2) 因为递归是占用栈内存的, 每次递归调用都会消耗一些栈内存. 因此必须在栈内存耗尽之前递归收敛
		   (终止), 否则就会栈溢出.
		3) 递归函数的使用是有一定风险的, 必须把握好.

	4. 可重入函数和递归函数
	
		1) 所有递归代码都是可重入的...但并非所有可重入代码都是递归的。
		2) 重入函数是保证在多线程环境下可以正常工作的函数. 
		   意味着虽然函数可以被一个线程访问, 但是另一个线程可以调用它...意味着每个函数都有单独的执行
		   堆栈和处理...因此, 函数不应包含任何可能损害或干扰执行的静态或共享变量.
		3) 可重入函数, 待了解(?????)
		
	5. 递归说明
		
		void digui(int n)
		{
			//int a[100];
			printf("递归前：n = %d.\n", n);
			if (n > 1)
			{
				digui(n-1);
			}
			else
			{
				printf("结束递归，n = %d.\n", n);
			}
			printf("递归后：n = %d.\n", n);
		}
		
		程序运行后的打印信息为:
			递归前：n = 5.
			递归前：n = 4.
			递归前：n = 3.
			递归前：n = 2.
			递归前：n = 1.
			结束递归，n = 1.
			递归后：n = 1.
			递归后：n = 2.
			递归后：n = 3.
			递归后：n = 4.
			递归后：n = 5.
			
		注意: 递归前打印5次, 打印完后才打印递归后. 因此第一次函数调用后, 并没有返回, 就进行了下一次调用.

//=======================================================================================================
										4.6.8.函数库
//-------------------------------------------------------------------------------------------------------
	1. 什么是函数库?
	
		1) 函数库就是一些事先写好的函数的集合, 给别人复用.
		2) 函数是模块化的, 因此可以被复用. 我们写好了一个函数, 可以被反复使用. 也可以A写好了一个函数然
		   后共享出来, 当B有相同的需求时就不需自己写直接用A写好的这个函数即可.

	2. 函数库的由来
	
		1) 最开始是没有函数库, 每个人写程序都要从零开始自己写. 时间长了慢慢的早期的程序员就积累下来了
		   一些有用的函数.
		2) 早期的程序员经常参加行业聚会, 在聚会上大家互相交换各自的函数库.
		3) 后来程序员中的一些大神就提出把大家各自的函数库收拢在一起, 然后经过校准和整理, 最后形成了一
		   份标准化的函数库, 就是现在的标准的函数库, 譬如说glibc.
		   
		总结: 标准库glibc

	3. 函数库的提供形式：动态链接库与静态链接库
	
		1) 早期的函数共享都是以源代码的形式进行的. 这种方式共享是最彻底的(后来这种源码共享的方向就形
		   成了我们现在的开源社区). 但是这种方式有它的缺点, 缺点就是无法以商业化形式来发布函数库.
		   
		2) 商业公司需要将自己的有用的函数库共享给被人(当然是付费的), 但是又不能给客户源代码. 这时候的
		   解决方案就是以库(主要有2种：静态库和动态库)的形式来提供.
		   
		3) 比较早出现的是静态链接库. 静态库其实就是商业公司将自己的函数库源代码经过只编译不连接形成.o
		   的目标文件, 然后用ar工具将.o文件归档成.a的归档文件(.a的归档文件又叫静态链接库文件). 商业公
		   司通过发布.a库文件和.h头文件, 来提供静态库给客户使用; 客户拿到.a和.h文件后, 通过.h头文件得
		   知库中的库函数的原型, 然后在自己的.c文件中直接调用这些库文件, 在连接的时候链接器会去.a文件
		   中拿出被调用的那个函数的编译后的.o的二进制代码段链接进去形成最终的可执行程序.
		   
		4) 动态链接库比静态链接库出现的晚一些, 效率更高一些, 是改进型的. 现在我们一般都是使用动态库.
		   静态库在用户链接自己的可执行程序时, 就已经把调用的库中的函数的代码段链接进最终可执行程序中
		   了, 这样好处是可以执行, 坏处是太占地方了. 尤其是有多个应用程序都使用了这个库函数时, 实际上
		   在多个应用程序最后生成的可执行程序中都各自有一份这个库函数的代码段. 当这些应用程序同时在内
		   存中运行时, 实际上在内存中有多个这个库函数的代码段, 这完全重复了. 而动态链接库本身不将库函
		   数的代码段链接入可执行程序, 只是做个标记. 然后当应用程序在内存中执行时, 运行时环境发现它调
		   用了一个动态库中的库函数时, 会去加载这个动态库到内存中, 然后以后不管有多少个应用程序去调用
		   这个库中的函数都会跳转到第一次加载的地方去执行(不会重复加载).
		   
		总结:
				1) 静态链接库, 只编译不链接形成.o文件, 用AR工具形成归档文件.a ; 发布时为归档文件.a和
				   头文件.h .
				2) gcc编译默认使用动态库, 需要显式用-static来强制静态链接.
				3) (????) 动态库不将函数的代码段链接到可执行程序中, 当应用程序在内存中执行时, 才加载
				    到内存(怎么理解??)?????

	4. 函数库中库函数的使用
	
		1) gcc中编译链接程序默认是使用动态库的, 要想静态链接需要显式用-static来强制静态链接.
		
		2) 库函数的使用需要注意3点：
		
			第一, 包含相应的头文件;
			第二, 调用库函数时注意函数原型;
			第三, 有些库函数链接时需要额外用-lxxx来指定链接;
			第四, 如果是动态库，要注意-L指定动态库的地址.

//=======================================================================================================
										4.6.9.字符串函数
//-------------------------------------------------------------------------------------------------------
	1. 什么是字符串
	
		1) 字符串就是由多个字符在内存中连续分布组成的字符结构.
		2) 字符串的特点是指定了开头(字符串的指针)和结尾(结尾固定为字符'\0'), 而没有指定长度(长度由开头
		   地址和结尾地址相减得到).

	2. 为什么要讲字符串处理函数
	
		1) 函数库为什么要包含字符串处理函数? 因为字符串处理的需求是客观的, 所以从很早开始人们就在写很
		   多关于字符串处理的函数, 然后逐渐形成了现在的字符串处理函数库.
		2) 面试笔试时, 常用字符串处理函数也是经常考到的点.

	3. 常用字符串处理函数
	
		1) C库中字符串处理函数包含在string.h中, 这个文件在ubuntu系统中在/usr/include中.
		
		2) 常见字符串处理函数及作用：

			memcpy		确定src和dst不会overlap，则使用memcpy效率高
			memmove		确定会overlap或者不确定但是有可能overlap，则使用memove比较保险
			memset
			memcmp
			memchr
			strcpy
			strncpy
			strcat
			strncat
			strcmp
			strncmp
			strdup
			strndup
			strchr
			strstr
			strtok
			・・・・・・・
		3) 如何查阅字符串函数的使用
			1) man 3 函数名.
			2) 查看string.h函数原型.  /usr/include/string.h.
			3) baidu.

//=======================================================================================================
										4.6.10.数学库函数
//-------------------------------------------------------------------------------------------------------
	1. math.h
	
		1) 真正的数学运算的函数定义在：/usr/include/i386-linux-gnu/bits/mathcalls.h.
		2) 使用数学库函数的时候, 只需要包含math.h即可. math.h 中包含<bits/mahtcalls.h>.
		

	2. 使用举例:计算开平方
	
		1) 库函数：double sqrt(double x);

		2) 编译时警告:
		
			4.6.10.math.c:9:13: warning: incompatible implicit declaration of built-in function
			‘sqrt’ [enabled by default]
			double b = sqrt(a);
			
			编译错误: 这里是编译警告, 没有声明函数.
		
		3) 	
			4.6.10.math.c:(.text+0x1b): undefined reference to `sqrt'
			collect2: error: ld returned 1 exit status

			链接错误：
				a) "ld" 表示是链接错误.
				b) sqrt函数有声明(声明就在math.h中), 有引用(在math.c)但是没有定义,链接器找不到函数体. 
				
		4) 链接时添加 -lm, 告诉编译器在libm中去查找函数即可.
			gcc xx.c -lm
			
	3. 链接错误根源
	
		1) sqrt本来是库函数, 在编译器库中是有.a和.so链接库的(函数体在链接库中的).
		
		2) C链接器的工作特点：因为库函数有很多, 链接器去库函数目录搜索的时间比较久. 为了提升速度想了
		   一个折中的方案：链接器只是默认的寻找几个最常用的库, 如果是一些不常用的库中的函数被调用, 需
		   要程序员在链接时明确给出要扩展查找的库的名字. 
		   
		3) 链接时可以用-lxxx来指示链接器去到libxxx.so中去查找这个函数.
		
		4) -lm指的是数学库. 如果是其他的库,可能是lxx.
		
	4. 链接时加-lm
	
		1) -lm就是告诉链接器到libm中去查找用到的函数.

		2) 实战中发现在高版本的gcc中, 经常会出现每加-lm也可以编译链接的.

	5. 可执行文件依赖的库查询命令: ldd (下节还有介绍)

		ldd a.out可以查看使用的动态库

		1) 没有使用数学库的可执行程序, 用ldd命令后的输出信息:

				linux-gate.so.1 =>  (0xb76f0000)
				libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb752a000)
				/lib/ld-linux.so.2 (0xb76f1000)

		2) 使用数学库的可执行程序, 用ldd命令后的输出信息:

				linux-gate.so.1 =>  (0xb7758000)
				libm.so.6 => /lib/i386-linux-gnu/libm.so.6 (0xb76fb000)			// math动态链接库
				libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb754c000)
				/lib/ld-linux.so.2 (0xb7759000)
				
	总结: 
			1) math库函数不属于常用库, 如果使用, 需要在连接时明确给出查找库的名字.  加 -lm.
			2) 动态链接库的后缀名是.so(对应windows系统中的dll), 静态库的扩展名是.a .
			3) 静态链接库.a(archiveuse), 静态链接库.so(sharedobject)
//=======================================================================================================
									4.6.11.自己制作静态链接库并使用
//-------------------------------------------------------------------------------------------------------
	1. 自己制作静态链接库
		
		1) 使用gcc -c只编译不连接, 生成.o文件;
		
			首先编写.c文件的函数(不能用main函数名), .h头文件.
		
		2) 使用ar工具进行打包成.a归档文件.

		说明:
				a) -c 只编译不链接.
				b) ar 是一个命令, 是工具链里面的一个工具, 叫打包器或归档器.  -rc (c就是创建), 利用
                   xx.o打包成 libxx.a的归档文件(库文件).
				c) 库名不能随便乱起, 一般是lib+库名称, 后缀名是.a表示是一个归档文件.
				d) 制作出来了静态库之后, 发布时需要发布.a文件和.h文件.

		其他:
			1) makefile 文件内容:
				all:
					gcc aston.c -o aston.o -c			// 只编译不链接
					ar -rc libaston.a aston.o			// xx.o打包成 libxx.a 库文件
		
	2. 使用静态链接库
	
		1) 把.a和.h都放在新工程的文件夹下, 然后在.c文件中包含库的.h, 然后直接使用库函数.
		
		2) 第一次, 编译方法：gcc test.c -o test
		
			报错信息：test.c:(.text+0xa): undefined reference to `func1'
			test.c:(.text+0x1e): undefined reference to `func2'
			
			说明链接错误, 库函数不是系统默认链接库的搜素范围内, 需要用户指定.
			(!!!!****!!!!!) 指定库名字时 -lxx, xx = 库文件名去掉前面的'lib'和'.a'.
			
		3) 第二次, 编译方法：gcc test.c -o test -laston

			报错信息：/usr/bin/ld: cannot find -laston
			collect2: error: ld returned 1 exit status
			
			指定了链接库文件名, 但是没有指定路径. 如果在当前目录下, 是'L.' .

		4) 第三次, 编译方法：gcc test.c -o test -laston -L.	
		
			无报错, 生成test, 执行正确.

	3. nm命令, 查看库文件.a中都有哪些符号
	
		...testlib# nm libaston.a 

		aston.o:
		00000000 T func1
		00000014 T func2
				 U puts

//=======================================================================================================
									4.6.12.自己制作动态链接库并使用
//-------------------------------------------------------------------------------------------------------

//=======================================================================================================

//--------------------------------------------

	1. 动态链接库和静态链接库后缀
	
		动态链接库的后缀名是.so(对应windows系统中的dll), 静态库的扩展名是.a .
		
	2. 创建一个动态链接库.
		
		1) 编写.c文件的函数(不能用main函数名), .h头文件.
		
		2) 编写makefile文件:
			all:
				gcc aston.c -o aston.o -c -fPIC
				gcc -o libaston.so aston.o -shared 

			a) -fPIC是位置无关码.
			b) -shared是按照共享库的方式来链接.
			
		3) 布库时, 发布libxxx.so和xxx.h即可.
		
		
	3. 使用自己创建的共享库
	
		1) 第一步, 编译方法：gcc test.c -o test

			报错信息：test.c:(.text+0xa): undefined reference to `func1'
			test.c:(.text+0x1e): undefined reference to `func2'
			collect2: error: ld returned 1 exit status

		2) 第二步, 编译方法：gcc test.c -o test -laston

			报错信息：/usr/bin/ld: cannot find -laston
			collect2: error: ld returned 1 exit status

		3) 第三步, 编译方法：gcc test.c -o test -laston -L.
			
			编译成功, 但是运行出错, 报错信息：
			
			error while loading shared libraries: libaston.so: cannot open shared object file: 
			   No such file or directory

			a) 错误原因：动态链接库运行时需要被加载(运行时环境在执行test程序的时候发现他动态链接了
			          libaston.so, 于是乎会去固定目录(/usr/lib)尝试加载libaston.so, 如果加载失败则
					  会打印以上错误信息.)
						
				(????) 链接时, 用了-L. 应该是链接时,也需要.so文件. 但是链接完成的可执行代码
					   中并没有实际加载使用的函数内容. 运行时,还需要使用.so文件. 而执行时并没有
					  指定目录(L.只是编译链接的时候使用的.so的目录)

			b) 解决方法一：
				
				将libaston.so放到固定目录下就可以了, 这个固定目录一般是/usr/lib目录.

				cp libaston.so /usr/lib即可
				
				(缺点): 一般/usr/lib 不放置用户的一些共享库. 
				

			c) 解决方法二：
				
				使用环境变量LD_LIBRARY_PATH. 
				
				操作系统在加载固定目录/usr/lib之前, 会先去LD_LIBRARY_PATH这个环境变量所指定的目录下去
				寻找, 如果找到就不用去/usr/lib下面找了, 如果没找到再去/usr/lib下面找. 所以解决方案就
				是将libaston.so所在的目录导出到环境变量LD_LIBRARY_PATH中即可.
				
				
				export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/mnt/hgfs/Winshare/s5pv210/AdvancedC/
				             4.6.PreprocessFunction/4.6.12.sharedobject.c/sotest

			d) 在ubuntu中还有个解决方案三，用ldconfig
				
				把目录添加到一个目录中,然后再修改一些配置文件, 系统除了在/usr/lib目录寻找外, 还会在
				这个目录下寻找.  
				
				这里不做过多介绍.

	4. ldd命令：
	
		作用是可以在一个使用了共享库的程序执行之前, 解析出这个程序使用了哪些共享库, 并且查看这些
	    共享库是否能被找到, 能被解析(决定这个程序是否能正确执行).
		   
		示例:
			1) 去掉LD_LIBRARY_PATH的路径:
				export LD_LIBRARY_PATH= 				// 去掉韩静变量定义
				
			2) 运行程序, 报错:
				 error while loading shared libraries: libaston.so: cannot open shared object file: 
				       No such file or directory
					   
			3) 用ldd检查可执行文件:
				
				.../sotest# ldd test					// 这里时可执行文件 
				
				linux-gate.so.1 =>  (0xb76e3000)
				libaston.so => not found				// 这里表示程序运行会有问题.
				libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb751d000)
				/lib/ld-linux.so.2 (0xb76e4000)			

			4) 重新设置LD_LIBRARY_PATH, 运行正确. ldd查看可执行test
			
				ldd test
				
				linux-gate.so.1 =>  (0xb773c000)
				libaston.so (0xb7736000)				// 动态链接库存在.
				libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7573000)
				/lib/ld-linux.so.2 (0xb773d000)

		总结: 
				1) ldd 用来运行一些可执行程序, 可以测试动态链接库是否可用.