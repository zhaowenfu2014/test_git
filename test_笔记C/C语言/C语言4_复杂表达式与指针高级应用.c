/*
//=======================================================================================================
								4.4.C语言复杂表达式与指针高级应用
//=======================================================================================================
4.4.1.指针数组与数组指针
4.4.2.函数指针与typedef
4.4.3.函数指针实战1
4.4.4.函数指针实战2
4.4.5.再论typedef
4.4.6.二重指针
4.4.7.二维数组
4.4.8.二维数组的运算和指针
//=======================================================================================================
								4.4.1.指针数组与数组指针
//-------------------------------------------------------------------------------------------------------
	1. 字面意思来理解 '指针数组' 与 '数组指针'
	
		1) 指针数组 的实质是一个数组, 这个数组中存储的内容全部是指针变量.
		2) 数组指针 的实质是一个指针, 这个指针指向的是一个数组.
		
	2. 分析指针数组与数组指针的表达式

		1) int *p[5]; int (*p)[5];	int *(p[5]);

		2)一般规律：
			int *p; (p是一个指针);  
			int p[5];(p是一个数组)
		
		总结：我们在定义一个符号时. 关键在于：首先要搞清楚你定义的符号是谁(第一步：找核心); 其次
		      再来看谁跟核心最近、谁跟核心结合(第二步：找结合); 以后继续向外扩展(第三步：继续向外
			  结合直到整个符号完).
			  
		3) 如何核心和 * 结合, 表示核心是指针; 如果核心和[]结合, 表示核心是数组; 如果核心和()结合,表示
			核心是函数. 
	   
		4) 用一般规律来分析3个符号：
	
			a) int *p[5];
		
				核心是p, []优先级比*高. p是一个数组,数组有5个元素大, 数组中的元素都是指针,
				指针指向的元素类型是int类型的了. 整个符号是一个指针数组.
		   
			b) int (*p)[5];
		
				核心是p, p是一个指针, 指针指向一个数组, 数组有5个元素, 数组中存的元素是int类型.
				总结一下整个符号的意义就是数组指针.
			
			c) int *(p[5]); 
			
				解析方法和结论和第一个相同, ()在这里是可有可无的.

	注意：符号的优先级到底有什么用? 其实是决定当2个符号一起作用的时候决定哪个符号先运算, 哪个符号
	      后运算.

	总结: 
			1) 优先级和结合性是分析符号意义的关键.
			   在分析C语言问题时不要胡乱去猜测规律, 不要总觉得c语言无从捉摸, 从已知的规律出发按照
			   既定的规则去做即可.
			   
			2) 学会逐层剥离的分析方法.
			   找到核心后从内到外逐层的进行结合, 结合之后可以把已经结合的部分当成一个整体, 再去和
			   整体外面的继续进行结合.
			   
			3) 基础理论和原则是关键, 没有无缘无故的规则.

//=======================================================================================================
								4.4.2.函数指针与typedef
//-------------------------------------------------------------------------------------------------------
	1. 函数指针的实质(还是指针变量)
	
		1) 函数指针的实质还是指针, 还是指针变量. 本身占4字节(在32位系统中, 所有的指针都是4字节).
		
		2) 函数指针、数组指针、普通指针之间并没有本质区别, 区别在于指针指向的东西是个什么玩意.
		
		3) 函数的实质是一段代码, 这一段代码在内存中是连续分布的(一个函数的大括号括起来的所有语句
		   将来编译出来生成的可执行程序是连续的), 所以对于函数来说很关键的就是函数中的第一句代码
		   的地址, 这个地址就是所谓的函数地址, 在C语言中用函数名这个符号来表示.
		   
		4) 结合函数的实质, 函数指针其实就是一个普通变量, 这个普通变量的类型是函数指针变量类型, 
		   它的值就是某个函数的地址(也就是它的函数名这个符号在编译器中对应的值).

	2. 函数指针的书写和分析方法
	
		1) C语言本身是强类型语言(每一个变量都有自己的变量类型), 编译器可以帮我们做严格的类型检查.
		
		2) 所有的指针变量类型其实本质都是一样的, 但是为什么在C语言中要去区分它们, 写法不一样呢
		  (譬如int类型指针就写作int *p; 数组指针就写作int (*p)[5]，函数指针就得写得更复杂)?
		  
		3) 假设我们有个函数是：void func(void);  对应的函数指针：void (*p)(void); 类型是：
		   void (*)(void);
		   
		4) 函数名和数组名最大的区别就是：函数名做右值时加不加&效果和意义都是一样的; 但是数组名做
		   右值时加不加&意义就不一样.
		   
		5) 写一个复杂的函数指针的实例：譬如函数是strcpy函数
		   (char *strcpy(char *dest, const char *src);), 对应的函数指针是：
		   char *(*pFunc)(char *dest, const char *src);



	3. typedef关键字的用法
		1) typedef是C语言中一个关键字, 作用是用来定义(或者叫重命名类型).
		
		2) C语言中的类型一共有2种：一种是编译器定义的原生类型(基础数据类型, 如int、double之类的);
		   第二种是用户自定义类型, 不是语言自带的是程序员自己定义的(譬如数组类型、结构体类型、函数
		   类型・・・・・).
		   
		3) 我们今天讲的数组指针、指针数组、函数指针等都属于用户自定义类型.
		
		4) 有时候自定义类型太长了, 用起来不方便, 所以用typedef给它重命名一个短点的名字.
		
		注意：typedef是给类型重命名, 也就是说typedef加工出来的都是类型, 而不是变量.
	
		// 这句重命名了一种类型, 这个新类型名字叫pType, 类型是：char* (*)(char *, const char *);
		typedef char* (*pType)(char *, const char *);
		
		char* (*p1)(char *, const char *);
		char* (*p2)(char *, const char *);
		
		pType p3;		// 等效于 char* (*p3)(char *, const char *);
		pType p4;

	

	总结：函数指针的分析方法也是源于优先级与逐层剥离的基本理论.
		  更复杂的typedef:
		  // 函数指针数组
		  //typedef char* (*pType[5])(char *, const char *);

	-----------------------------(!!!!!!!!*******!!!!!!!)----------------------------------
	1. 定义一个变量时,需要指明数据类型. 且变量名放置的位置是不同的. 比如:
	
		int i;					// 变量i
		int *p;					// 指针变量p
		int a[10];				// 数组a
		void (*pf)(void);		// 函数指针pf
		int (*p)[5];			// 数组指针变量p
		
		a) 变量名为 i, p, a, pf.
		
		b) 数据类型为 int , int * , 数组(10个元素) , void返回/void输入参数的函数(void (*)(void)),
		   数组指针(int (*) [5]).
		   
		c) 定义变量,要指明数据类型.  这里是给编译器看的. 
			数据类型和变量放置的位置有多种形式: 有的变量名放在后边, 有的放在中间.
		d) 
			void (*pf)(void);  // 这里面的数据类型可以视为 void (*)(void); 变量视为 pf.
			int (*p)[5];	   // 这里面的数据类型可以视为 int (*)[5]; 变量视为p.
			
			(!!!!!) 其实每一种定义都是一种习惯. 比如,按照int i;的定义, 数组的定义完全可以定义为
			        int [5] a; 	但是每一种的定义中的数据类型和变量位置需要特殊记忆.
	2. 数组名取址
		1) 
			int *p;
			int a[5];
			
			p = a;			// 类型匹配的, 所以编译器不会警告不会报错.
			//p = &a;		// 类型不匹配, p是int *, &a是数组的地址, 是int (*)[5];
		2) 
		
			int a[5];
			int (*p1)[5] ;

			p1 = &a;		// p1类型是int (*)[5], &a的类型也是int (*)[5]
		
		(!!!!!!) int a[5]; &a的类型是int (*)[5]
	
	3. 函数名取址
		
			void (*pFunc)(void);
			//pFunc = func1;			// 左边是一个函数指针变量，右边是一个函数名
			pFunc = &func1;				// &func1和func1做右值时是一模一样的，没任何区别
			pFunc();					// 用函数指针来解引用以调用该函数

		a) 函数指针定义 : void (*pFunc)(void);
		
				类型是 void (*)(void), 变量是 pFunc.
		
		b) 函数指针赋值:
		
				pFunc = func1; 或者 pFunc = &func1;
				
			函数名就是函数的地址, 可以直接赋值给函数指针.
			
			(!!!!!!) 函数取地址, 给函数名一样. 编译器就是这么认为的.
			
			(!!!!!!) &func1和func1做右值时是一模一样的, 没任何区别. 数组名则不同.
			
		c) 函数指针的调用: pFunc();		
		
	4. 函数指针举例
		char a[5] = {0};
		char* (*pFunc)(char *, const char *);	// 定义一个函数指针pFunc. 
		
		pFunc = strcpy;
		pFunc(a, "abc");
		
		printf("a = %s.\n", a);

		a) 定义一个函数指针, pFunc. 类型可以认为是 char* (*)(char *, const char *).
		b) 调用时, pFunc(a, "abc");
		
	5. 函数指针类型,属于用户自定义数据类型. 不属于基础数据类型.
		因为每一个函数指针,都涉及到函数参数的类型和个数, 因此这里的指针数据类型, 编译器会用到(取
		参数时?)?
		
		
	-----------------------------(!!!!!!!!*******!!!!!!!)----------------------------------

//=======================================================================================================
								4.4.3.函数指针实战1
//-------------------------------------------------------------------------------------------------------
	1. 用函数指针调用执行函数
	
		1) 最简单的函数指针来调用函数的示例, 在上节课中已经演示过了.
		
		2) 本节演示的是用函数指针指向不同的函数来实现同一个调用执行不同的结果.
		
		3) 如果学过C++或者Java或者C#等面向对象的语言, 就会知道面向对象三大特征中有一个多态. 多态就是
		   同一个执行实际结果不一样, 跟我们这里看到的现象其实是一样的.
		   
	2. 代码实现:
		
		1) typedef 一个函数指针类型
			
			// 定义了一个类型pFunc, 这个函数指针类型指向一种特定参数列表和返回值的函数.
			typedef int (*pFunc)(int, int);
		
		2) 定义一个函数指针.
			
			// 定义一个函数指针, 指针类型信息为	int (*)(int, int).		
			pFunc p1 = NULL;

		3) 函数指针赋值
		
			switch (c)
			{
				case '+':
					p1 = add; break;
				case '-':
					p1 = sub; break;
				case '*':
					p1 = multiply; break;
				case '/':
					p1 = divide; break;
				default:
					p1 = NULL;	break;
			}
			
		4) 函数调用
			
			result = p1(a, b);

	3. printf()函数使用时注意
		
		1) inux中命令行默认是行缓冲的, 意思就是说当我们程序printf输出的时候, linux不会一个字一个字
		   的输出我们的内容, 而是将其缓冲起来放在缓冲区等一行准备完了再一次性把一行全部输出出来(为
		   了效率). linux判断一行有没有完的依据就是换行符'\n'(windows中换行符是\r\n,  linux中是\n,
		   iOS中是\r). 
	
		2) printf是一个行缓冲函数, 先写到缓冲区, 满足条件后, 才将缓冲区刷到对应文件中. 刷缓冲区的
		   条件如下：
	
			a) 缓冲区填满.

			b) 写入的字符中有‘\n’ '\r'.

			c) 调用fflush手动刷新缓冲区.

			d) 调用scanf要从缓冲区中读取数据时, 也会将缓冲区内的数据刷新.
		
		3) 写程序时需要注意
			
			printf()使用时,最好是以\r\n结尾. 这样能强制缓冲区数据刷新.
			
			不过不写\r\n, printf不会输出, 调试程序时, 可能会引起误判.

	4.  scanf()函数使用时注意
	
		1) scanf是和系统的标准输入打交道, printf和标准输出打交道. 要完全搞清楚这些东西得把标准输入
		   标准输出搞清楚. 
		   
		2) 用户在输入内容时结尾都会以\n结尾, 但是程序中scanf的时候都不会去接收最后的\n.  导致这个回
		   车符还存留在标准输入中. 下次再scanf时就会先被拿出来, 这就导致你真正想拿的那个数反而没机
		   会拿.导致错误.
		
			可以通过程序,取出上次输入的换行符.
		
			printf("请输入要操作的2个整数:");
			scanf("%d %d", &a, &b);
			
			printf("请输入操作类型：+ | - | * | /");
			
			do 
			{
				scanf("%c", &c);			// 取出上次输入的换行符.
			}while (c == '\n');

			switch (c)
			{
				
			}

//=======================================================================================================
								4.4.4.函数指针实战2
//-------------------------------------------------------------------------------------------------------
	1. 结构体内嵌函数指针实现分层
	
		1) 程序为什么要分层? 因为复杂程序东西太多一个人搞不定, 需要更多人协同工作, 于是乎就要分工.
		   要分工先分层, 分层之后各个层次由不同的人完成, 然后再彼此调用组合共同工作.
		   
		2) 本程序要完成一个计算器, 我们设计了2个层次：上层是framework.c, 实现应用程序框架; 下层是
		   cal.c, 实现计算器. 实际工作时cal.c是直接完成工作的, 但是cal.c中的关键部分是调用的framework.c
		   中的函数来完成的.
		   
		3) 先写framework.c, 由一个人来完成. 这个人在framework.c中需要完成计算器的业务逻辑, 并且把相应
		   的接口写在对应的头文件中发出来, 将来别的层次的人用这个头文件来协同工作.
		   
		4) 另一个人来完成cal.c, 实现具体的计算器; 这个人需要framework层的工作人员提供头文件来工作(但
		   是不需要framework.c).

	2. 总结：

		第一：本节和上节实际完成的是同一个习题, 但是采用了不同的程序架构.
		
		第二：对于简单问题来说, 上节的不分层反而容易理解, 反而简单; 本节的分层代码不好理解, 看起来有
		      点把简单问题复杂化的意思. 原因在于我们这个问题本身确实是简单问题, 而简单问题就应该用简
			  单方法处理. 我们为什么明知错误还要这样做? 目的是向大家演示这种分层的写代码的思路和方法.
			  
		第三：分层写代码的思路是：有多个层次结合来完成任务, 每个层次专注各自不同的领域和任务; 不同层
		      次之间用头文件来交互.
			  
			  (!!!!!) 不同层次之间, 通过.h文件就可以, 不用知道.c具体的实现. (!!!!!!)
			  
		第四：分层之后上层为下层提供服务, 上层写的代码是为了在下层中被调用.
		
		第五：上层注重业务逻辑, 与我们最终的目标相直接关联, 而没有具体干活的函数.
		
		第六：下层注重实际干活的函数, 注重为上层填充变量, 并且将变量传递给上层中的函数(其实就是调用上
		      层提供的接口函数)来完成任务.
			  
		第七：下层代码中其实核心是一个结构体变量(譬如本例中的struct cal_t), 写下层代码的逻辑其实很简
		      单：第一步先定义结构体变量; 第二步填充结构体变量; 第三步调用上层写好的接口函数, 把结构
			  体变量传给它既可.
			  
		注意: 
			(!!!!??????) 这里上层和下层的理解.  LINUX操作系统内核属于上层.  下层代码定义结构体变量, 
			             填充变量, 调用上层的函数.
						 
						 LINUX驱动结构就是这种分层的, 移植/写驱动就是实现下层代码: 定义结构体, 填充
						 变量, 调用函数传参数进去实现功能.  
						 
						写驱动的难点在于, 怎么定义结构体的变量, 怎么填充这些变量, 怎么调用上层哪一个
						函数去实现功能.
						 
			(??????) 这里上层和下层是不是反了?????

//=======================================================================================================
								4.4.5.再论typedef
//-------------------------------------------------------------------------------------------------------
	1. C语言的2种类型：内建类型与用户自定义类型
	
		内建类型ADT		: 	int, float...
		自定义类型UDT	: 	结构体,数组,typedef定义的类型)

	2. typedef定义(或者叫重命名)类型而不是变量
	
		1) 类型是一个数据模板, 变量是一个实在的数据. 类型是不占内存的, 而变量是占内存的.
		2) 面向对象的语言中：类型就是类class, 变量就是对象.
		
	3. typedef与#define宏的区别
	
		typedef char *pChar1;
		#define pChar2 char *

		pChar1 p1,  p2;			// 两个都是指针.
		pChar2 p3,  p4;			// 一个指针,一个不是.


	4. typedef与结构体
	
		1) 结构体在使用时都是先定义结构体类型, 再用结构体类型去定义变量.
		
		2) C语言语法规定: 结构体类型使用时必须是 " struct 结构体类型名 结构体变量名;" 这样的方式
		   来定义变量.
		   
		3) (!!!!!!!******!!!!!!!)
			使用typedef相当于定义了一个类型, 同时typedef 重命名了一下.
		
			typedef struct student
			{
				char name[20];
				int age;
			}student_t;

			(!!!!!!!) C编译器也允许student_t写成student. 


		4)  (!!!!!!!******!!!!!!!)
			使用typedef一次定义2个类型, 分别是结构体变量类型, 和结构体变量指针类型.

			// 我们一次定义了2个类型：
			// 第一个是结构体类型，有2个名字：struct teacher，teacher
			// 第二个是结构体指针类型，有2个名字：struct teacher *， pTeacher
			typedef struct teacher
			{
				char name[20];
				int age;
				int mager;
			}teacher, *pTeacher;
			
			(!!!!!) ',' 表示tpyedef 一下定义了两个类型.


	5. typedef与const
	
		1) typedef int *PINT;	  const PINT p2; 相当于是int *const p2;  (!!!!!!******)
		
		2) typedef int *PINT;	  PINT const p2; 相当于是int *const p2;  (!!!!!!******)
		
		3) 如果确实想得到const int *p; 这种效果, 只能 typedef const int *CPINT; CPINT p1;

	6. 使用typedef的重要意义(2个：简化类型、创造平台无关类型)
	
		1) 简化类型的描述:
		
			char *(*)(char *, char *);		
			
			typedef char *(*pFunc)(char *, char *);	// (!!!!!), 定义一个函数指针新类型 pFunc.
			
			
		2) 很多编程体系下, 人们倾向于不使用int、double等C语言内建类型, 因为这些类型本身和平台是相关
		   的(譬如int在16位机器上是16位的, 在32位机器上就是32位的). 为了解决这个问题, 很多程序使用
		   自定义的中间类型来做缓冲. 譬如linux内核中大量使用了这种技术.
		   
			内核中先定义：typedef int size_t; 然后在特定的编码需要下用size_t来替代int.
			(譬如可能还有typedef int len_t).
			
		3) STM32的库中全部使用了自定义类型, 譬如typedef volatile unsigned int vu32.

//=======================================================================================================
									4.4.6.二重指针
//-------------------------------------------------------------------------------------------------------
	1. 二重指针与普通一重指针的区别
	
		1) 本质上来说, 二重指针和一重指针的本质都是指针变量, 指针变量的本质就是变量.
		
		2) 一重指针变量和二重指针变量本身都占4字节内存空间.
		
	2. 二重指针的本质
	
		1) 二重指针本质上也是指针变量, 和普通指针的差别就是它指向的变量类型必须是个一重指针. 二重指针
		   其实也是一种数据类型, 编译器在编译时会根据二重指针的数据类型来做静态类型检查, 一旦发现运算
		   时数据类型不匹配编译器就会报错.
		   
		2) C语言中如果没有二重指针行不行? 其实是可以的. 一重指针完全可以做二重指针做的事情, 之所以要
		   发明二重指针(函数指针、数组指针), 就是为了让编译器了解这个指针被定义时定义它的程序员希望
		   这个指针被用来指向什么东西(定义指针时用数据类型来标记, 譬如int *p, 就表示p要指向int型数据),
		   编译器知道指针类型之后可以帮我们做静态类型检查. 编译器的这种静态类型检查可以辅助程序员发现
		   一些隐含性的编程错误, 这是C语言给程序员提供的一种编译时的查错机制.
		   
		3) 为什么C语言需要发明二重指针? 原因和发明函数指针、数组指针、结构体指针等一样的. 为了做类型
		   检查.
		
	3. 二重指针的用法
	
		1) 二重指针指向一重指针的地址.
		
		2) 二重指针指向指针数组的.

			int *p1[5];
			int *p2;
			int **p3;
			
			//p2 = p1;		// 错误, 类型不匹配.
			p3 = p1;		// p1是指针数组名, 本质上是数组名, 数组名做右值表示数组首元素
							// 首地址. 数组的元素就是int *类型, 所以p1做右值就表示一个int *
							// 类型变量的地址, 所以p1就是一个int类型变量的指针的指针, 所以
							// 它就是一个二重指针int **.
		
		3) 实践编程中二重指针用的比较少, 大部分时候就是和指针数组纠结起来用的.
		
		4) 实践编程中有时在函数传参时为了通过函数内部改变外部的一个指针变量, 会传这个指针变量的
		   地址(指针的指针,也就是二重指针)进去. 
		   
			void func(int **p)
			{
				*p = (int *)0x12345678;
			}
	
			int a = 4;
			int *p = &a;				// p指向a
			printf("p = %p.\n", p);		// p打印出来就是a的内存地址
			func(&p);					// 在func内部将p指向了别的地方 (函数修改指针变量的值, 传址)
			printf("p = %p.\n", p);		// p已经不指向a了，所以打印出来不是a的地址
			*p = 23;					// 因为此时p指向0x12345678，但是这个地址是不
	

	4. 二重指针与数组指针
	
		1) 二重指针、数组指针、结构体指针、一重指针、普通变量的本质都是相同的, 都是变量.
		
		2) 所有的指针变量本质都是相同的, 都是4个字节, 都是用来指向别的东西的, 不同类型的指针变量只是
		   可以指向的(编译器允许你指向的)变量类型不同.
		   
		3) 二重指针就是：指针数组指针.

//=======================================================================================================
									4.4.7.二维数组
//-------------------------------------------------------------------------------------------------------
	1. 二维数组的内存映像
	
		1) 一维数组在内存中是连续分布的多个内存单元组成的, 而二维数组在内存中也是连续分布的多个内存单
		   元组成的. 
		2) 从内存角度来看, 一维数组和二维数组没有本质差别.
		3) 二维数组int a[2][5]和一维数组int b[10]其实没有任何本质差别. 我们可以把两者的同一单元的对应
		   关系写下来:
				a[0][0]	 a[0][1]   a[0][4]	 a[1][0]	a[1][1]	  a[1][4]	
				b[0]	 b[1]	   b[4]	     b[5]	    b[6]	  b[9]
		4) 既然二维数组都可以用一维数组来表示, 那二维数组存在的意义和价值在哪里? 二维数组a和一维数组b
		   在内存使用效率、访问效率上是完全一样的(或者说差异是忽略不计的). 在某种情况下用二维数组而不
		   用一维数组, 原因在于二维数组好理解、代码好写、利于组织.
		   
		总结：我们使用二维数组(C语言提供二维数组), 并不是必须, 而是一种简化编程的方式. 想一下, 一维数组
		      的出现其实也不是必然的, 也是为了简化编程.

	2. 哪个是第一维哪个是第二维？
		1) 二维数组int a[2][5]中, 2是第一维, 5是第二维. (从做到右)
		2) 结合内存映像来理解二维数组的第一维和第二维的意义. 首先第一维是最外面一层的数组, 所以
		   int a[2][5]这个数组有2个元素; 其中每一个元素又是一个含有5个元素的一维数组(这个数组就是
		   第二维).
		   
		总结：二维数组的第一维是最外部的那一层, 第一维本身是个数组. 这个数组中存储的元素也是个一维数组;
		      二维数组的第二维是里面的那一层, 第二维本身是个一维数组. 数组中存的元素是普通元素, 第二维
			  这个一维数组本身作为元素存储在第一维的二维数组中.

	3. 二维数组的下标式访问和指针式访问
	
		1) 回顾：一维数组的两种访问方式. 
			以int b[10]为例, int *p = b; .
			b[0] 等同于 *(p+0);   b[9] 等同于 *(p+9);  b[i] 等同于 *(p+i).
		
		2) 二维数组的两种访问方式：以int a[2][5]为例, (合适类型的)p = a;
			a[0][0]等同于*(*(p+0)+0); 	a[i][j]等同于 *(*(p+i)+j)

//=======================================================================================================
								4.4.8.二维数组的运算和指针
//-------------------------------------------------------------------------------------------------------
	1. 指针指向二维数组的数组名
		1) 二维数组的数组名表示二维数组的第一维数组中首元素(也就是第二维的数组)的首地址.
		2) 二维数组的数组名a等同于&a[0], 这个和一维数组的符号含义是相符的.
		3) 用数组指针来指向二维数组的数组名是类型匹配的.

		测试:
			
		int a[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};
		
		//int *p1 = a;		// 类型不匹配
		//int **p2 = a;		// 类型不匹配
		
		// 指针指向二维数组的数组名
		int (*p3)[5];		// 数组指针, 指针指向一个数组, 数组有5个int类型元素.
		p3 = a;				// a是二维数组的数组名, 作为右值表示二维数组第一维的数组
							// 的首元素首地址, 等同于&a[0]
		p3 = &a[0];			// 匹配, a是二维数组, a[0] 是一个一维数组, 地址可以给p3(p3就是指向以为数组的). 
		
		注意(!!!!!): int **p2 = a; 类型不匹配.
	
	2. 指针指向二维数组的第一维
	
		1) 	第一维a[i]

		
		int a[2][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};
		
		//int *p4 = &a[0];		// 不可以
		int *p4 = a[0];			// a[0]表示二维数组的第一维的第一个元素, 相当于是
								// 第二维的整体数组的数组名. 数组名又表示数组首元素
								// 首地址, 因此a[0]等同于&a[0][0];
		
		int *p5 = &a[0][0];		// 	a[0] 与 &a[0][0]相同.

		注意(!!!!!): a[0] 相当于二维数组的数组名(类比一维数组b[], 二维数组a[][]中,a[]就是第二维
		             的数组名).
			

	3. 指针指向二维数组的第二维
		1) 二维数组的第二维元素其实就是普通变量了(a[1][1]其实就是int类型的7), 已经不能用指针类型和它
		   相互赋值了.
		2) 除非int *p = &a[i][j]; 

	总结：二维数组和指针的纠葛, 关键就是2点：
		1、数组中各个符号的含义.
		2、数组的指针式访问, 尤其是二维数组的指针式访问.

//=======================================================================================================















































