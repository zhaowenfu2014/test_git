/*
//============================================================================================
	1. C语言的编写步骤:
		1) 编辑代码
			#include <stdio.h>

			int main(int argc, char ** argv)
			{
			   printf("hello linux! \r\n");
			   return 0;
			}
		
		2) 编译,在linux中使用编译器一般是gcc
			gcc hello.c 
			gcc hello.c -o hello
		3) 执行程序
			./hello
		4) 反复调试
	2. printf()函数中的\n换行符合\连接符.
		打印图形
			*
		   ***
		  *****
		   ***
		    *
		printf("\n   *		\
				\n  ***		\
				\n *****	\
				\n  ***		\
				\n	 * 		\
				\n ");
//--------------------------------------------------------------------------------------------

//============================================================================================
3、C语言数据类型
	基本数据类型: 整形,浮点型,字符型.
	符合数据类型: 数组,结构体,共同体.
3.1、整形
	
	(1)int: 			整形
	(2)short int:		简写为short, 短整形（<=整形）
	(3)long int:		简写为long, 长整型（>=整形）
	
3.2、浮点型

	C语言中浮点型对应数学中的小数,浮点型有float和double两种.
	使用方式相同,不同在于表示范围和精度. 
	float表示的范围小,精度低(小数点后6位);
	double表示范围大，精度高(小数点后16位).

注意：printf中打印float或double类型,要是用%f. 可以规定小数后面位数.
	  printf("f1 = %.20f",i);		// 默认小数点后面是六位. 可以认为设置位数.
	  如果设置过大,比如20,则打印的后续位数不准确. 

3.3、字符型

	字符型对应ASCII字符,字符型一般用8位二进制表示,无符号字符型范围是0~255.
	字符型其实是一种比short还短的整形,所以它可以和int相运算.

3.4、有符号数和无符号数
	
有符号数：
	整形：signed int（简写为 int）
		  signed long，也写作signed long int，(简写为long)
		  signed short，也写作signed short int(简写为short)
		  signed（表示signed int）
	浮点型：
		  signed float(简写为float)
		  signed double(简写为double)
	字符型：
		  signed char(简写为char)
		
无符号数：
	整形：整形有无符号数，用来表示一些编码编号之类的东西。譬如身份证号，房间号
		unsigned int(没有简写)
		unsigned long int(简写unsigned long)
		unsigned short int（简写为unsigned short）
	
	浮点数：没有无符号浮点数.也就是说,小数一般只用在数学概念中,都是有符号的.
	
	字符型：字符型有无符号数
		unsigned char（没有简写）
	4. 不同类型占用的空间:
		数据类型的实质是内存中格子的不同种类。譬如在32位机器上
			短整形格子（short）					占用2字节空间 16位
			整形格子（类型是int）、				占用4字节空间 32位
			单精度浮点型格子（float）、			占用4字节空间
			双精度浮点型格子（double）、		占用8字节空间 64位
			字符型格子（char）					占用1字节空间 8位	
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
	1.
	函数定义：函数定义是关键，是这个函数的实现。函数定义中包含了函数体，函数体中的代码段.
	决定了这个函数的功能。
	
	函数声明：函数声明实际上是叫函数原型声明。什么叫原型？函数的原型包含三部分：函数名，
	返回值类型，函数参数列表。通俗讲，函数原型就是这个函数叫什么，接收什么类型的几个参数，
	返回一个什么样的返回值。
	
	函数声明的作用，在于告诉使用函数的人，这个函数使用时应该传递给他什么样的参数，它会返回
	什么样类型的返回值。这些东西都是写函数的人在函数定义中规定好的，如果使用函数的人不参照
	这个原型来使用，就会出错，结果就会和你想的不一样。

	函数调用：函数调用就是使用函数名来调用函数完成功能。调用时必须参照原型给函数传参，
	然后从函数得到适当的返回值作为结果。
	2.函数参数：
	形参：形式参数的简称。在函数定义和函数声明中的参数列表中的参数，都是形参。
	实参：实际参数的简称。函数调用中，实际传递的参数才是实参。

	函数调用的过程，其实就是实参传递给形参的一个过程。这个传递实际是一次拷贝。
	实际参数的时候，实参（本质是一个变量）本身并没有进入到函数内，而是把自己的值
	复制了一份传给了函数中的形参，在函数中参与运算。这种传参方法，就叫做传值调用。
//--------------------------------------------------------------------------------------------
	1.
		一个局部变量，但是没有初始化的时候，这个值是随机的。
		一个全局变量，但是没有初始化的时候，这个值是0。
	2. 数组初始化:
		1) 完全舒适化:
		2) 不完全初始化: 初始化式中的值从a[0]开始，依次向后赋值，不足的默认用0填充赋值.
		int b[5] = {0};
		(!!!!!)gcc还允许 int a[5] = {100,12,[4]=99};  // a[0]是100,a[1]是12,a[4] = 99.
		
		例如:
			int main(int argc, char ** argv)
			{
				int a[5] = {1,2,3,4,5};
				int b[5] = {0};
				int c = 10;
				int d;
				int i;
				
				for(i=0;i<5;i++) printf("a[%d]=%d, ",i,a[i]);
				printf("\n");
				
				for(i=0;i<5;i++) printf("b[%d]=%d, ",i,b[i]);
				printf("\n");

				printf("&a=%ld, &b=%ld,",(long)&a, (long)&b);

				printf("&c=%ld, &d=%ld,",(long)&c, (long)&d);
				
				printf("\n");
				
				return 0;
			}
		结果:
			a[0]=1, a[1]=2, a[2]=3, a[3]=4, a[4]=5, 
			b[0]=0, b[1]=0, b[2]=0, b[3]=0, b[4]=0, 
			&a=140732988676800, &b=140732988676832,&c=140732988676788, &d=140732988676792,
		结论(???)
			1) 局部变量的初始化常量值,应该也是存在const类型的,在函数开始处复制到临时定义的数组?
			2) 对于没有全部赋值的数组, 是程序通过复制的操作完成的???
			3) 需要用keil c 测试一下,是如何处理的.
	3. 字符数组可以用字符串初始化:
		char a[] = "abcdef";
	4. 转义字符
		屏幕上看不见，没法显示，一般要用转义字符方式来显示。譬如'\n'表示回车符，'\t'表示Tab，
		'\0'代表空字符）

//--------------------------------------------------------------------------------------------
	1. sizeof运算符
		作用：返回一个变量或者一个数据类型的内存占用长度，以字节为单位。
		
		1) sizeof 是一个运算符.
			(???)需要用keil c反汇编查看一下, 编译器是如何实现的. 直接赋值? 如果是数组呢?
		
		2) 可以获取类型的长度,也可以测试变量的长度.
			sizeof(int);
			sizeof(a);
			
			测试数组元素个数: sizeof(a)/sizeof(a[0]);	

/*
//=======================================================================================================
	指针
//=======================================================================================================
	1. 
		1) 指针全称是指针变量,其实质是C语言的一种变量. 
		2) 指针存在的目的就是间接访问,有了指针之后，我们访问某个变量不必只通过这个变量名来访问.
	2. (!!!!!)
		*：指针符号,指针符号在指针定义和指针操作的时候,解析方法是不同:
		1) int *p;		定义指针变量p，这里的*p含义不是代表指针变量p所指向的那个变量,
						在定义时,这里的*含义是告诉编译器p是一个指针.
		2) 使用指针的时候,*p则代表指针变量p所指向的那个变量.
	
	3.	指针定义的两种理解方法： 
		int *p;	
		第一种：首先看到p,这个是变量名; 其次,p前面有个*,说明这个变量p是一个指针变量;最后,*p前面有一个
				int,说明这个指针变量p所指向的是一个int型数据.

			char *(*pfunc)(char *, char *) 					// 一个函数指针,函数返回值是 char *类型.
			(???)char *(*(*pfunc)[])(char *, char *)  类似的复杂表达式，可以用相同的分析方法得到

		第二种：首先看到p,这个是变量名;其次,看到p前面的int *,把int *作为一个整体来理解,int *是一种
				类型(复合类型),该类型表示一种指向int型数据的指针.

		总结：第二种方法便于理解,但是不够本质;建议用第一种方法来理解,因为这种思维过程可以帮我们理解
			  更复杂的表达式.

	4. 指针与数组的初步结合
		1) 数组名：做右值时,数组名表示数组的首元素首地址,因此可以直接赋值给指针.
			       是一个常量,不能做左值.
		2) 如果有 int a[5]; int *p;
			则 a和&a[0]都表示数组首元素a[0]的首地址.
			而&a则表示数组的首地址.
			
			(!!!!!) p = &a;     // 编译器会警告. 应该复制给一个int型数组指针.


		注意：数组首元素的首地址和数组的首地址是不同的.
			  前者是数组元素的地址, 而后者是数组整体的地址.
			  两个东西的含义不同,但是数值上是相同的. (?????)
//=======================================================================================================
	结构体, 共同体(公用体,联合)
//=======================================================================================================
	1. 结构体的初始化
		第一种，完全初始化。{xx, xx, xx, xx, xx};		// , 隔开
		第二种，部分初始化。							// , 隔开
			{
				.a = xx,
				.b = xx,
				.c = xx,
				.d = xx,
			};
	2. 共用体union在定义和使用形式上,和结构体struct很相似.
		结构体,是对多个数据的组合与封装.
		共用体,共用体中只有一个东西，只是它被好几个名字（和类型）共用.
		
		union myUnion
		{
			int a;
			char b;
			float c;
			
		};

		int main(char argc, char **argv)
		{
		   union myUnion var;
		   
		   //var.a = 100;
		   var.c = 100;
		   
		   printf("a = %d, b = %d, c = %f. \n",var.a, var.b, var.c);
		   return 0;
		}
		
		1) 如果给a复制100:
			输出: a = 1120403456, b = 0, c = 100.000000. 
		2) 如果给c复制100:
			输出: a = 100, b = 100, c = 0.000000.
	3. 什么时候使用结构体,什么时候使用共同体.
		struct Male
		{
			int age;
			char name[30];
			int basketball_score;		// 篮球成绩
		};
		struct Female
		{
			int age;
			char name[30];
			int aerobics_score;			// 体操成绩
		};
		union student
		{
			struct Female f;
			struct Male m;
		}
		
		main()
		{
			union student s[30];
			
			s[0].m.basketball_score = 88;
			s[1].f.aerobics_score = 90;			// s[1],是女生
		}
		
		1) 结构体,所有的属性都需要: 不管是男生还是女生,都需要年龄,姓名,成绩.
		2) 共用体,只需要多选一: 学生不是男生就是女生.
		
		当某种通信有多种编码方式时,且每种编码方式的属性都差不多,可以使用共同体定义编码方式.
/=======================================================================================================
	宏定义,枚举
//=======================================================================================================
	1. 需要注意问题:
		1) 需要先定义后使用.
		2) 宏一般用大写,变量一般用小写.
		3) (!!!!!!)每个.c文件都需要包含宏定义,否则可能会判断错误.
		如果一个.h中定义一个宏: #define  DEBUG_PRINT ON
		
		使用的.c文件: #if(DEBUG_PRINT==ON)
			
		必须保证.c文件包含了宏定义的.h文件.
		4) 宏定义需要时要加括号
		
			#define SEC_PER_YEAR 	(365*24*60*60)UL
	2. 带参数的宏
		#define S(r)	(3.14*r*r)    //

	3. 枚举
		枚举可以认为是宏定义的一种优化:
			#define	SUN		0
			#define	MON		1
			#define	TUS		2
			#define	WEN		3
			#define	THR		4
			#define	FRI		5
			#define	SAT		6
			
			main()
			{
				int day;
				
				day = 8;			// 赋值错误
				
				switch(day)
				{
					case SUN:
					
						break;
					...	
					
				}
			}
			
			程序可能赋值错误.
			
			enum week
			{
				SUN = 0,
				MON,
				TUS,
				WEN,
				THR,
				FRI,
				SAT,
			};
			main()
			{
				enum week day;
				
				day = SAT;			// 如果赋值其他,会报错.
				
				switch(day)
				{
					case SUN:
					
						break;
					...	
					
				}
			}
		(!!!!) 另外, 枚举可以把宏定义归类.  
//=======================================================================================================
	基础知识：
	(!!!!!)1、double float用%f打印，char用%c和%d打印，int用%d，字符串用%s打印，指针用%p打印

//=======================================================================================================













//=======================================================================================================
//						C语言进阶篇 - 数据类型
//=======================================================================================================
	1. 基本数据类型
		数据类型分2类：基本数据类型+复合类型
		1) 基本类型：char short int long float double
		2) 复合类型：数组 结构体 共用体 类（C语言没有类，C++有）
		
		(!!!!!) char,short,int long等整形数据,存储方式基本相同,只是数据位数不同. 
			    float,double等浮点型数据,存储方式与整形不同.

	1.1 内存占用与sizeof运算符
		数据类型就好像一个一个的模子,这个模子实例化出C语言的变量.
		一个变量占用多少空间是由变量的数据类型决定的.
		每种数据类型,在不同的机器平台上占用内存是不同的.
		我们一般讲的时候都是以32位CPU为默认硬件平台来描述：
			char 		1字节		8位
			short 		2字节		16位
			int 		4字节		32位
			long 		4字节		32位
			float 		4字节		32位
			double		8字节		64位

	1.2 有符号数和无符号数
		对于char short int long等整形类型的数,都分有符号有无符号数.
		而对于float和double这种浮点型数来说,只有有符号数,没有无符号数.

		unsigned int 无符号数,32位(4字节)全部用来存数的内容 所以表示的数的范围
		是0 ~ 4294967295(2^32 - 1).
		signed int   有符号数,32位中最高位用来存符号（0表示正数，1表示负数）,剩余的31位用
		来存数据.所以可以表示的数的范围是 	-2147483648(2^31)	~ 2147483647(2^31 - 1).


	1.3 整形数和浮点型数存储方式上的不同 
		对于float和double这种浮点类型的数,它在内存中的存储方式和整形数不一样.所以float和
		int相比,虽然都是4字节,但是在内存中存储的方式完全不同.
		
		所以同一个4字节的内存,如果存储时是按照int存放的,取的时候一定要按照int型方式去取.
		如果存的时候和取的时候理解的方式不同,那数据就完全错了.
		
		(!!!!)即定义时的类型,和printf时的类型要一致.


	2 空类型（关键字void）
		C语言中的void类型,代表任意类型.而不是空的意思.
		
		任意类型的意思不是说想变成谁就变成谁,而是说它的类型是未知的,是还没指定的. 
		(!!!!!)同时也通知编译器,类型可以不做检查.
		void *	是void类型的指针,void类型的指针的含义是：这是一个指针变量,该指针指向一个
		void类型的数. void类型的数就是说这个数有可能是int,也有可能是float,也有可能是个结构体,哪种类型
		都有可能,只是我当前不知道.

		(!!!!!)void型指针的作用就是,程序不知道那个变量的类型,但是程序员自己心里知道.
		程序员如何知道? 当时给这个变量赋值的时候是什么类型,现在取的时候就还是什么类型.这些类型对不对,
		能否兼容,完全由程序员自己负责. 编译器看到void就没办法帮你做类型检查了.

		(?????)在函数的参数列表和返回值中，void代表的含义是：
		一个函数形参列表为void,表示这个函数调用时不需要给它传参.
		返回值类型是void,表示这个函数不会返回一个有意义的返回值.所以调用者也不要想着去使用该返回值.
		(以上是朱的说法,个人认为函数参数和返回值理解为空更合适)
		
		举例:
			void main(void)
			{
				int a = 5;
				
				void *pVoid;
				
				pVoid = &a;
				
				printf(" *pVoid = %d. \n", *(int *)pVoid);			// 先强制转化为int型指针
				printf(" *pVoid = %f. \n", *(float *)pVoid);		// 先强制转化为float型指针
			}
			// 编译器不再检查void 类型是否正确.
			// 先强制转换为某一个类型的指针,再取指向的变量.
			
	(!!!) C语言设计基本理念：
		C语言相信程序员永远是对的,C语言相信程序员都是高手,C语言赋予了程序员最大的权利.
		所以C语言的程序员必须自己对程序的对错负责,必须随时脑袋清楚,知道自己在干嘛.

	3 数据类型转换
		不同类型的变量是不能直接运算的,需要做转换.
		1) 隐式转换
			编译器自动进行,隐式类型转换默认朝精度更高、范围更大的方向转换.
			
			a) int a = 3;
			   float b = 3.5;
			   int c;
			   
			   c = a + b;
			   
			   printf("c = %d \n", c);
			   
			   解析: 编译器发现a,b类型不同,需要隐式转换,将a转换为float,复制给一个中间变量f1,
					 之后与b相加,得到一个float的结果6.500000; 之后要赋值给int型的c,编译器发现类型不匹配,
					 还需要转换类型(这里是赋值,所以必须以左边的变量类型为准),转化为int型给c;最后结果
					 c = 6;
			b) 上例中,如果最后打印的:  printf("c = %f \n", c).
				
				(?????)(!!!!!) 实际测试,编译器会警告,但是也进行了隐式转换(×).
				(参考d)
			c)  int a = 3;
			    float b = 3.5;	 
				printf("a + b = %f \n", a + b);
				
				运行结果 a + b = 6.500000		// a + b , 用一个临时变量,完成计算,有隐式转换.
			d) 	
				int a = 3;
				float b = 3.5;
				
				printf("a + b = %f. \n",a+b);
				printf("a = %d. \n",a);
				printf("a = %f. \n",a);		

				a + b = 6.500000. 
				a = 3. 
				a = 6.500000.
				(!!!!!!) 这里最后一步打印还是异常, 所以 编译器这种情况下应该是没有进行隐式转换.
				直接按照float数据格式在a变量存储的地址,取出了数据显示的.
				
		2) 强制类型转换
			C语言默认不会这么做,但是程序员可以强制进行.
			
	4 C语言与bool类型
		C语言中原生类型没有bool,C++中有. 
		在C语言中如果需要使用bool类型,可以用int来代替(0为假,非0为真):
			很多代码体系中，用以下宏定义来定义真和假
				#define TRUE	1
				#define FALSE	0
//=======================================================================================================
//							C语言进阶篇 - 变量
//=======================================================================================================
	1. 基本概念
		1) 作用域
				是变量的一个重要属性. 表示变量起作用的范围.
		2) 代码块
				就是用{}括起来的一段代码.
		3) 数据段
				数据段存的是数，像全局变量就是存在数据段的.
		4) 代码段
				存的是程序代码，一般是只读的.
		5) 栈(stack)
				先进后出, C语言中局部变量就分配在栈中.
	2. 变量类型
		1) 局部变量
			a) 普通局部变量(auto), 
				auto int i;			// auto可以省略.
			b) 静态局部变量(static),
			
			c) register变量
				egister类型的局部变量表现上和auto是一样的. 
				register被称为：C语言中最快的变量. C语言的运行时环境承诺,会尽量将register类型的
				变量放到寄存器中去运行(普通的变量是在内存中).
				
				但是它是有限制的：首先寄存器数目是有限的,所以register类型的变量不能太多;
				其次register类型变量在数据类型上有限制,譬如你就不能定义double类型的register变量.
				一般只在内核或者启动代码中,需要反复使用同一个变量这种情况下才会使用register类型变量.

		2) 全局变量
				普通全局变量
				静态全局变量
					定义全局变量并不是为了别.c文件使用,这是自己使用.
	3. 普通局部变量和普通全局变量区别
		1) 定义区域
				定义在函数中的变量,就是局部变量. 
				定义在函数外边的变量就是全局变量.
		2) 非初始化的情况
			定义同时没有初始化则:
				局部变量的值是随机的.
				全局变量的值是默认为0.
		3) 作用域区别
				局部变量只有代码块作用域.
				全局变量具有文件作用域.
		4) 生命周期区别
				全局变量是在程序开始运行之前的初始化阶段就诞生,到整个程序结束退出的时候才死亡.
				局部变量在进入局部变量所在的代码块时诞生,在该代码块退出的时候死亡.	
		5) 分配位置区别 (!!!!!)
				全局变量分配在数据段上.
				局部变量分配在栈上.
	4. 静态局部变量
			静态局部变量定义时前面加static关键字。
		1) 静态局部变量在第一次函数被调用时创造并初始化, 但在函数退出时它不死亡. 
			而是保持其值等待函数下一次被调用. 下次调用时不再重新创造和初始化该变量.
			静态局部变量的这种特性,和全局变量非常类似.
		2) 静态局部变量和全局变量的不同点在于作用域不同.
	5. 静态全局变量
		
	6. 多个.c文件工程
		1) 整个程序可以包含多个.c文件, 但只能有一个main()函数.
		2) 函数和全局变量在C语言中可以跨文件引用,也就是说他们的连接范围是全局的,具有文件连接属性.
			总之意思就是全局变量和函数是可以跨文件看到的(直接影响就是,我在a.c和b.c中各自定义了一个函数
			func,名字相同但是内容不同,编译报错).
		3) 简单的C语言程序（项目）只有一个C文件(a.c), 编译的时候gcc a.c -o a,执行的时候./a
			复杂的C语言程序（项目）是由多个C文件构成的,譬如一个项目中包含2个c文件（a.c, b.c）,
			编译的时候 gcc a.c b.c -o ab，执行的时候 ./ab
	7. 变量跨文件使用
		1) 局部变量,静态全局变量都不可以.
		2) 全局变量可以使用,但是要先声明为extern.
			(!!!!!!) 其实是为了告诉编译器该变量的数据类型.

	8. 变量,函数的三要素
		变量,函数都有定义、声明、引用三要素. 其中,定义是创造这个变量或者函数,声明是向编译器
		交代它的原型,引用是使用这个变量或函数.所以如果没有定义只有声明和引用,编译时一定会
		报错.
//=======================================================================================================
//							C语言进阶篇 - 常量
//=======================================================================================================
	1. 常量的三种形式
		1) #define定义的常量
		2) const关键字定义
		3) 枚举常量
	2. #define定义的常量
		#define N 20			// 符号常量
		int a[N];
	3. const关键字定义常量
		1) const int i = 14		// 告诉编译器,该变量时常量, 不能再赋值.
		2) const和指针结合，共有4种形式(!!!!!):
		
			const int *p;			p是一个指针, 指针指向一个int型数据, p所指向的是个常量.	
			
			int const *p;			p是一个指针, 指针指向一个int型数据. p所指向的是个常量. 
			
			int *const p;			p是一个指针, 指针指向一个int型数据. p本身是常量, p所指向的是个变量.
					
			const int *const p;		p是一个指针, 指针指向一个int型数据. p本身是常量, 指向的也是常量.		
		(!!!!!)
			结论和记忆方法：
			a) const在*前面, 就表示const作用于p所指向的量. 所以这时候p所指向的是个常量.
			b) const在*后面, 表示p本身是常量, 但是p指向的不一定是常量.	
		3) const型指针的作用:
			char *strcpy(chasr *dst, const char *src);
			字符串复制函数,它的函数功能是把src指向的字符串,拷贝到dst中.
			
	4. 枚举常量
		枚举常量是宏定义的一种替代品,在某些情况下会比宏定义好用.
		enum
//=======================================================================================================
//							C语言进阶篇 - 头文件
//=======================================================================================================
	1. 为什么需要头文件？
		从之前可以看到,函数的声明是很重要的.当我们在一个庞大的项目中,有很多个源文件,每一个源文件中都有
		很多个函数,并且需要在各个文件中相互穿插引用函数.
		
		怎么解决函数的声明问题? 靠头文件.
		
		声明都放在.h头文件中, 在需要声明的地方,包含头文件就可以.

	2. #include包含头文件时，用<>和""的区别

	1) <>用来包含系统自带的头文件, 是编译器或者库函数或者操作系统提供的头文件.
	2) ""用来包含项目目录中的头文件, 这些一般是我们自己写的.
	

	3. 防止重复包含头文件
		#ifndef __A_H__
		#define __A_H__
			// C语言头文件中的声明
		#endif

	4. 写程序时, 最好不要在头文件中定义变量. 因为这时该头文件被多个源文件包含时, 就会出现重复定义问题.
		全局变量的定义就应该放在某个源文件中, 然后在别的源文件中使用前是extern声明.

//=======================================================================================================








//=======================================================================================================





	




















//============================================================================================
// 设置ubuntu复制数据到WIN
//============================================================================================
	1. VMWARE点击 虚拟机-> 重新安装VMware Tools ...
	2. ubuntu界面下左侧出现光驱标记, 鼠标选中其中的文件,复制到~/ 下的一个目录.
	3. 从命令行进入刚才复制的目录中. 解压缩:
		tar -zxvf VMwareTools-10.3.10-13959562.tar.gz 
	4. 运行 vmware-install.pl,一直默认. (点击ENTER)
		./vmware-install.pl
	5. 安装完成后,重启虚拟机.
//============================================================================================
VMWare共享文件夹使用
//============================================================================================
	1. 当我们裸机安装了Windows,并且在Windows中安装了虚拟机软件VMWare,并且在虚拟机中安装了
	ubuntu后.我们一般在Windows中编辑源代码,而在linux中编译、执行源代码.这时候就需要在Windows
	和linux之间进行交互.
		怎么来进行交互呢？之前通过smb服务器,现在通过VMWare的共享文件夹就可以轻松实现.
	2. 怎么建立Windows的共享文件夹？
		第一步：先在Windows中创建一个文件夹,主要要使用英文名称.
		第二步: VMWare中,菜单栏 VM -> Settings -> Options -> Shared Folders选项卡,
			右边上侧选择Always Enabled,下面点击Add,next,在打开的选项卡中Host Path
			项目中浏览选择刚才第一步中创建的文件夹,下面Name中会自动弹出一个相同的名字,
			这个名字是将来Windows中的文件夹在linux虚拟机中的映射文件夹,名字可以改也
			可以不改.然后一直OK,完成即可.
		第三步：在linux中,直接到 /mnt/hgfs目录下,即可找到刚才第二步中Name相同的名字的
				文件夹,这个目录即是第一步中Windows中目录在linux下的映射.	





//============================================================================================
